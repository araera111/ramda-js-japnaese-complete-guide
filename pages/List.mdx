---
title: "List"
---

List では配列に関する関数を扱います。array も list も js なら一緒や。

20 個

## all

```ts
import { all } from "ramda";

const arr1 = [3, 3, 3, 3, 3];
const arr2 = [3, 3, 3, 3, 1];

const isAll3 = all((x) => x === 3);

const arr1Result = isAll3(arr1);
console.log({ arr1Result }); // -> { arr1Result: true }

const arr2Result = isAll3(arr2);
console.log({ arr2Result }); // -> { arr2Result: false }

/* ライブラリなしで書くなら */
const arr1Result = arr1.every((x) => x === 3);
```

こんな感じで isAll3 関数とかをつくることができる。
JS の配列にある every と一緒。
基本的に配列に使用するなら every で良いけれど、条件が複雑で関数に切り出しておきたいときは all のほうが良いかも。

## any

これは下記例がわかりづらい気がする。  
つまり、ひとつの判定する関数に、値を複数配列で渡すことができる。  
そして、どちらかがその判定に合致していたときは true を返す、ということだろう。

```ts
import { any } from "ramda";

const numbers1 = [1, 2, 3, 4, 5];
const isEven = (num: number): boolean => num % 2 === 0;

const result1 = any(isEven, numbers1);
console.log({ result1 }); // { result1: true } 偶数条件に合致するものが配列にあるのでtrue

const numbers2 = [1, 1, 1, 1, 1];
const result2 = any(isEven, numbers2);
console.log({ result2 }); // { result2: false } 偶数のものが配列に存在しないのでfalse

/* 配列のメソッドならこう書けます。 */
const result3 = numbers1.some((x) => isEven(x));
const result4 = numbers2.some((x) => isEven(x));
console.log({ result3, result4 }); // { result3: true, result4: false }
```

## append

```ts
const users = ["TANAKA", "YAMADA"];
const newUser = "NAKAMURA";
const resultUsers = append(newUser, users);
console.log({ resultUsers }); // -> { resultUsers: [ 'TANAKA', 'YAMADA', 'NAKAMURA' ] }

/* ライブラリなしで書くなら */
const resultUsers = [...users, newUser];
```

こんな感じで足せます。
普通に js 風味でええやんってなるけど、pipe とかでつなぎたいときは ramda を使ったほうが便利。curry 化されているし。

## collectBy

```ts
import { collectBy, prop } from "ramda";

type Role = "一般社員" | "バイト" | "社長";

type User = {
  id: number;
  name: string;
  role: Role;
};

const shatyosan: User = {
  id: 1,
  name: "山田 太郎",
  role: "社長",
};

const bite: User = {
  id: 2,
  name: "かむ はなこ",
  role: "バイト",
};

const bite2: User = {
  id: 3,
  name: "かむかむ かむこ",
  role: "バイト",
};

const user: User = {
  id: 4,
  name: "しゃいん いちろう",
  role: "一般社員",
};

/* 上記のようなユーザーが配列に入っていたとする。 */
const users = [shatyosan, bite, bite2, user];

/* 社長、バイト、一般社員で配列に分ける関数 */
const collectByRole = (userList: User[]): User[][] =>
  collectBy(prop("role"), userList);

const result = collectByRole(users);
console.log(result);

/*
[
  [ { id: 1, name: '山田 太郎', role: '社長' } ],
  [
    { id: 2, name: 'かむ はなこ', role: 'バイト' },
    { id: 3, name: 'かむかむ かむこ', role: 'バイト' }
  ],
  [ { id: 4, name: 'しゃいん いちろう', role: '一般社員' } ]
]
このように分類してくれるのだ
*/
```

## concat

2 つの配列を足すことができます。  
実は文字にも使えます。  
concat は JS の配列のメソッドにもあります。(result3)  
配列を結合したいだけならメソッドでもいいです。  
ramda の利点はカリー化されているので処理を先送りにしたり、簡単に関数に分けたりできることです。

```ts
import { concat } from "ramda";

/* 配列の合体 */
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const result = concat(arr1, arr2);
console.log({ result });
// { result: [ 1, 2, 3, 4, 5, 6 ] }

/* ramdaなしでやるならこんな感じ */
const result2 = [...arr1, ...arr2];
console.log({ result2 });
// { result: [ 1, 2, 3, 4, 5, 6 ] }

/* そもそも配列のメソッドにもあるよ */
const result3 = arr1.concat(arr2);
console.log({ result3 });
// { result: [ 1, 2, 3, 4, 5, 6 ] }

/* 文字も合体できる */
const str1 = "AAAAAA";
const str2 = "BBBBBB";
const result4 = concat(str1, str2);
console.log({ result4 });
// { result5: 'AAAAAABBBBBB' }

/* 普通にやるなら */
const result5 = str1 + str2;
console.log({ result5 });
// { result5: 'AAAAAABBBBBB' }
```

## count

配列を渡して、ある条件に合致したものの数を返してくれます。

```ts
import { count } from "ramda";

const countEven = (arr: number[]): number => count((x) => x % 2 === 0, arr);

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const result = countEven(numbers);
console.log({ result }); // { result: 5 } (2,4,6,8,10)のカウント

type User = {
  id: number;
  name: string;
  age: number;
};

const countAge18OverUser = (arr: User[]): number =>
  count((x) => x.age >= 18, arr);

const users: User[] = [
  {
    id: 1,
    name: "TANAKA",
    age: 0,
  },
  {
    id: 2,
    name: "YAMADA",
    age: 18,
  },
  {
    id: 3,
    name: "HANAMURA",
    age: 19,
  },
];

const result2 = countAge18OverUser(users);
console.log({ result2 }); // { result2: 2 } -> YAMADAとHANAMURAは18歳以上
```

## countBy

集計を行う関数です。結果は object で返ってきます。  
下の例を見てもらうのがわかりやすいかも。

```ts
/*
  例：好きな色の集計を行いたい
*/

import { countBy } from "ramda";

/* 回答一覧。とりあえずidと名前はなんでもいいのでコピーで使いまわします。好きな色だけ変えてる。 */
const questionnaire1 = {
  id: 1,
  name: "TANAKA",
  favoliteColor: "red",
};
const questionnaire2 = {
  id: 2,
  name: "YAMADA",
  favoliteColor: "blue",
};
const questionnaire3 = {
  id: 2,
  name: "YAMADA",
  favoliteColor: "yellow",
};
const questionnaire4 = {
  id: 2,
  name: "YAMADA",
  favoliteColor: "blue",
};
const questionnaire5 = {
  id: 2,
  name: "YAMADA",
  favoliteColor: "blue",
};
const questionnaire6 = {
  id: 2,
  name: "YAMADA",
  favoliteColor: "yellow",
};
const questionnaire7 = {
  id: 2,
  name: "YAMADA",
  favoliteColor: "blue",
};
const questionnaire8 = {
  id: 2,
  name: "YAMADA",
  favoliteColor: "redi",
};

/* もっといろいろ回答があったが、こんな感じでfavoliteColorだけにしたとしよう */
const list = [
  questionnaire1,
  questionnaire2,
  questionnaire3,
  questionnaire4,
  questionnaire5,
  questionnaire6,
  questionnaire7,
  questionnaire8,
];

const countFavoliteColors = countBy((x) => x.favoliteColor, list);
console.log({ countFavoliteColors });
// { countFavoliteColors: { red: 1, blue: 4, yellow: 2, redi: 1 } } ←カウントしたことによってtypoしていたことも判明。

/*
  countBy の第一引数に関数を渡すことができて、ここでいろいろできます。  
  たとえば下は公式の例ですが、Math.floorで端数を切り捨てて、数字の頻度をカウントしています。 
  const numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
  R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
*/
```

## drop

下記は公式の例。  
与えられた引数の数だけ、配列の頭から消していく関数。  
これが意外と便利。  
ちなみに string にも使えます。slice とかより直感的に使える気がするな。

```ts
R.drop(1, ["foo", "bar", "baz"]); //=> ['bar', 'baz'] 1個目のfooが消えた
R.drop(2, ["foo", "bar", "baz"]); //=> ['baz'] 配列の頭から2個が消えた
R.drop(3, ["foo", "bar", "baz"]); //=> [] 空になった
R.drop(4, ["foo", "bar", "baz"]); //=> [] 超える数のときは空。エラーは返さない
R.drop(3, "ramda"); //=> 'da' 文字の頭3個を消した
```

## dropLast

drop の逆ですな。配列の後ろから消してくれる。  
文字列操作で結構便利だったりする。  
PSAEEGGD0001  
とかで後ろ 4 個取ってきてもらったり。

```ts
R.dropLast(1, ["foo", "bar", "baz"]); //=> ['foo', 'bar']
R.dropLast(2, ["foo", "bar", "baz"]); //=> ['foo']
R.dropLast(3, ["foo", "bar", "baz"]); //=> []
R.dropLast(4, ["foo", "bar", "baz"]); //=> []
R.dropLast(3, "ramda"); //=> 'ra'
```

## take

drop の逆で配列の頭から取得します。string にも使えます。

```ts
R.take(1, ["foo", "bar", "baz"]); //=> ['foo']
R.take(2, ["foo", "bar", "baz"]); //=> ['foo', 'bar']
R.take(3, ["foo", "bar", "baz"]); //=> ['foo', 'bar', 'baz']
R.take(4, ["foo", "bar", "baz"]); //=> ['foo', 'bar', 'baz']
R.take(3, "ramda"); //=> 'ram'
```

## takeLast

そうなると当然 takeLast もあるわな。  
配列の後ろから取得できます。string にも使えます。

```ts
R.takeLast(1, ["foo", "bar", "baz"]); //=> ['baz']
R.takeLast(2, ["foo", "bar", "baz"]); //=> ['bar', 'baz']
R.takeLast(3, ["foo", "bar", "baz"]); //=> ['foo', 'bar', 'baz']
R.takeLast(4, ["foo", "bar", "baz"]); //=> ['foo', 'bar', 'baz']
R.takeLast(3, "ramda"); //=> 'mda'
```

## filter

filter 関数。  
js の配列メソッドにはあるが、object にはない。

- object でも filter できる
- カリー化されているので pipe でつなぎやすい
  などのメリットがある。

一方、index を返してくれないので index を使ったフィルター処理はできません。

```ts
/* 公式例 */
const isEven = (n) => n % 2 === 0;
R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
R.filter(isEven, { a: 1, b: 2, c: 3, d: 4 }); //=> {b: 2, d: 4}

/*
  こんな感じでindexを使ったフィルターがjsの配列のmethodではできるが、ramdaだとできない。
  まあ、同じことやりたいならremove関数でよろしいが
  たとえば配列で偶数番目のものだけ抜き出すとかの処理はramdaだとできないかな？
*/
const filterByIndex = (arr: number[], targetIndex: number): number[] =>
  arr.filter((_, i) => i !== targetIndex);

/* そういうときはaddIndexを使えばよろしい */
import { addIndex, filter } from "ramda";

const numbers = [1, 2, 3, 4, 5, 6];
const filterByEvenIndex = addIndex(filter)((_, i) => i % 2 === 0);
const result = filterByEvenIndex(numbers);
console.log({ result }); // { result: [ 1, 3, 5 ] } 配列の偶数番目だけ

const numberObj = [{ a: "a", b: "b", c: "c", d: "d", e: "e" }];
const result2 = filterByEvenIndex(numberObj);
console.log({ result2 }); // { result2: [ { a: 'a', b: 'b', c: 'c', d: 'd', e: 'e' } ] } objectに使ってもindexは足されない
```

## uniq

配列から重複を取り除いてくれます。便利。

```ts
R.uniq([1, 1, 2, 1]); //=> [1, 2]
R.uniq([1, "1"]); //=> [1, '1']
R.uniq([[42], [42]]); //=> [[42]]
```

## adjust

adjust は引数 1 が index, 引数 2 が適用する関数、引数 3 が配列です。
下記例では a,b,c,d が入っている配列の、index1 に toUpper 関数を適用しています。

```ts
R.adjust(1, R.toUpper, ["a", "b", "c", "d"]); //=> ['a', 'B', 'c', 'd']
R.adjust(-1, R.toUpper, ["a", "b", "c", "d"]); //=> ['a', 'b', 'c', 'D']
```

## aperture

deepl
連続する要素の n 個のタプルからなる新しいリストを返す。n がリストの長さより大きい場合，空リストが返される。

動きはわかったけど、どういうところで使うのかいまいち想像できないなぁ……。

```ts
/* 1と2, 2と3, 3と4, 4と5で同じものが2回使われる配列にしてくれる */
R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]

/* 123 234 345と1個ずつずれた3個の組 */
R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]

/* 7つの組をつくれないので空配列が返ってくる */
R.aperture(7, [1, 2, 3, 4, 5]); //=> []
```

## chain

JS で言うところの flatMap ですかね。  
こういう関数、型がない JS なら便利なんだけど TS だとあんまり有効利用できない気がします。  
ちゃんとした関数型言語だと、もっとバシバシ型推論がきいて unknown じゃなくなるんだけど……。  
flatMap は、つまり結果が配列だったときに flat にしてくれる感じですな。  
map+filter の代わりに 1 回のループで処理できたりします。

```ts
import { chain, isNil } from "ramda";

const duplicate = (n: number): number[] => [n, n];
const result = chain(duplicate, [1, 2, 3]);
console.log({ result }); // { result: [ 1, 1, 2, 2, 3, 3 ] }

const deleteFalsy = (arr: (number | undefined)[]) =>
  chain((x) => (isNil(x) ? [] : x), arr);
const result2 = deleteFalsy([1, 2, 3, undefined]);
console.log({ result2 }); // { result2: [ 1, 2, 3 ] }
```

## dropLastWhile

引数 1 に pred 関数, 引数 2 に配列を取る。  
pred が false になったものから後ろを drop した結果が返ってくる。

```ts
const lteThree = (x: number): boolean => x <= 3; //3以下かどうかをbooleanで判定するpred関数

R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4] ←3以下条件に合致しなかった4から後ろを根こそぎ捨てる

R.dropLastWhile((x) => x !== "d", "Ramda"); //=> 'Ramd'
/* stringにも使える。xがdかどうかを後ろから判定し、falseになったものから後ろを根こそぎ捨てる */
```

## dropRepeats

drop 系何個あんねんな。  
これは連続していたものを drop する関数。  
どこで使うねんな。連続していたら消したいときなんだろうけど……。

```ts
R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
/* 1,1,1の部分が連続しているので1になる。2，3はそのまま。4,4と2,2も連続しているので4，2となる */
```

## dropRepeatsWith

dropRepeats の引数 1 に pred 関数を渡せる。  
動きはわかるけど、どこで使うねんな。  
dropRepeatsWith あってよかった〜ってなる場面があるんか？  
あるんやろうなぁ……。

```ts
const l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
/*
  1, -1, 1はMath.abs(絶対値)で同じものとして判定される -> 1
  3,はそのまま。
  4, -4, -4はMath.abs(絶対値)で同じものとして判定されるので4
  -5, 5も同じものなので-5
  3はそのまま
*/
```

## dropWhile

dropLastWhile の前から版。  
というか dropLastWhile が dropWhile の後ろから版なんよ。  
英語の l->w という語順のせいでこっちがあとに来るからドキュメントがややこしいねん。  
つまり引数 1 が pred 関数、引数 2 が配列。
条件に合致したものを前から消す。条件にあわないものがあったところで処理が止まる。

```ts
const lteTwo = (x: number): boolean => x <= 2; //2以下ならばtrue,

/* 前から見て1，2はlteTwoなので消す。3はlteTwofalseなのでそれ以降が残る */
R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]

R.dropWhile((x) => x !== "d", "Ramda"); //=> 'da'
```

## zipObj

※この回答は bing が回答しました。

ramda.js の zipObj 関数は、キーの配列と値の配列を受け取り、それらを対応させたオブジェクトを返す関数です 1。例えば、次のように使うことができます。

```javascript
const keys = [‘name', ‘age', ‘gender'];
const values = [‘Alice', 25, ‘female'];
const obj = R.zipObj(keys, values); // {name: ‘Alice', age: 25, gender: ‘female'}
```

この関数は、キーと値の配列の長さが異なる場合でも動作しますが、長い方の配列の余った要素は無視されます 1。例えば、次のようになります。

```javascript
const keys = [‘name', ‘age', ‘gender'];
const values = [‘Bob', 30];
const obj = R.zipObj(keys, values); // {name: ‘Bob', age: 30}
```

この関数は、オブジェクトのプロパティを作るのに便利です。例えば、次のようにして、人物の情報をオブジェクトに変換することができます。

```javascript
const person = [‘Charlie', 35, ‘male', ‘engineer'];
const keys = [‘name', ‘age', ‘gender', ‘occupation'];
const obj = R.zipObj(keys, person); // {name: ‘Charlie', age: 35, gender: ‘male', occupation: ‘engineer'}
```

## zipWith

※この回答は bing が回答しました。
ramda.js の zipWith 関数は、2 つの配列を引数にとり、それぞれの要素に対して指定した関数を適用して新しい配列を返す関数です 1。

例えば、2 つの数値の配列を引数にとり、それぞれの要素を足し合わせた配列を返す関数は、以下のように書けます。

```ts
const add = (a, b) => a + b;
const result = R.zipWith(add, [1, 2, 3], [4, 5, 6]); // [5, 7, 9]
```

また、2 つの文字列の配列を引数にとり、それぞれの要素を連結した配列を返す関数は、以下のように書けます。

```ts
const concat = (a, b) => a + b;
const result = R.zipWith(concat, ["a", "b", "c"], ["d", "e", "f"]); // ["ad", "be", "cf"]
```

zipWith 関数は、引数の配列の長さが異なる場合、短い方の配列の長さに合わせて処理を行います。

```ts
const result = R.zipWith(add, [1, 2, 3], [4, 5]); // [5, 7]
```

## traverse

以下は bingAI の回答です。
traverse 関数は、アプリカティブファンクターという概念を使って、配列やオブジェクトなどのコレクションを走査して、その要素に関数を適用し、結果を別のコレクションにまとめる関数です ⁴。

例えば、以下のようなコードがあります。

```ts
// 配列の要素に1を足す関数
const addOne = (x: number): number => x + 1;

// 配列の要素に2をかける関数
const multiplyByTwo = (x: number): number => x * 2;

// 配列の要素に関数を適用して、結果を配列にまとめる関数
const applyFunctions = (
  fns: Array<(x: number) => number>,
  xs: number[]
): number[][] => {
  return fns.map((fn) => xs.map(fn));
};

// 配列の要素に関数を適用して、結果を配列にまとめる関数を実行する
console.log(applyFunctions([addOne, multiplyByTwo], [1, 2, 3]));
// [[2, 3, 4], [2, 4, 6]]
```

このコードでは、applyFunctions 関数は、配列の要素に関数を適用して、結果を配列にまとめる関数です。この関数は、引数として関数の配列と数値の配列を受け取り、関数の配列の要素を順に数値の配列の要素に適用して、結果を配列にまとめて返します。この関数は、配列の要素に関数を適用するという処理を自分で書いていますが、これは ramda.js の traverse 関数を使って書くことができます。

ramda.js の traverse 関数は、以下のような型を持ちます ⁴。

```ts
// traverse関数の型
traverse(of: (x: any) => any, fn: (x: any) => any, traversable: any): any;
```

この関数は、of という関数と fn という関数と traversable というコレクションを引数に受け取り、of と fn を使って traversable を走査して、結果を別のコレクションにまとめて返します。of という関数は、コレクションの要素をラップする関数で、fn という関数は、コレクションの要素に適用する関数です。traversable というコレクションは、配列やオブジェクトなど、走査できるものです。

例えば、applyFunctions 関数は、以下のように traverse 関数を使って書くことができます。

```ts
// 配列の要素に1を足す関数
const addOne = (x: number): number => x + 1;

// 配列の要素に2をかける関数
const multiplyByTwo = (x: number): number => x * 2;

// 配列の要素に関数を適用して、結果を配列にまとめる関数
const applyFunctions = (
  fns: Array<(x: number) => number>,
  xs: number[]
): number[][] => {
  return R.traverse(R.of, (fn) => R.map(fn, xs), fns);
};

// 配列の要素に関数を適用して、結果を配列にまとめる関数を実行する
console.log(applyFunctions([addOne, multiplyByTwo], [1, 2, 3])); // [[2, 3, 4], [2, 4, 6]]
```

このコードでは、R.of という関数と fn => R.map(fn, xs)という関数と fns という配列を traverse 関数に渡しています。
R.of という関数は、引数を配列にラップする関数で、fn => R.map(fn, xs)という関数は、引数として関数を受け取り、その関数を xs という配列の要素に適用する関数です。fns という配列は、関数の配列です。traverse 関数は、R.of と fn => R.map(fn, xs)を使って fns を走査して、結果を配列にまとめて返します。この結果は、applyFunctions 関数と同じになります。

## transpose

以下は bingAI の回答です。

ramda.js の transpose 関数について、わかりやすい具体例とともに教えてくださいというご質問ですね。

transpose 関数は、2 次元配列の行と列を入れ替える関数です。例えば、以下のような 2 次元配列があるとします。

```ts
// 2 次元配列
const array: number[][] = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];
```

この 2 次元配列を transpose 関数に渡すと、以下のような結果が返ります。

```ts
// transpose 関数を実行する
console.log(R.transpose(array));
// [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
```

この結果は、元の 2 次元配列の行と列が入れ替わっていることがわかります。transpose 関数は、2 次元配列の各列を新しい配列の要素としてまとめて返します。この処理は、以下のように書くこともできます ³。

```ts
// transpose 関数と同じ処理をする関数
const transpose = (array: any[][]): any[][] => {
return array[0].map((\_, colIndex) => array.map(row => row[colIndex]));
};
```

この関数は、2 次元配列の最初の要素（配列）を map 関数に渡して、その要素のインデックスを colIndex として受け取ります。そして、そのインデックスに対応する 2 次元配列の各行の要素を新しい配列にまとめて返します。これを繰り返して、2 次元配列の行と列を入れ替えた新しい 2 次元配列を作ります。

以上が、ramda.js の transpose 関数について、わかりやすい具体例とともに教えてくださいというご質問への回答です。マークダウン形式で書き出しましたが、`を`に置き換えてください。コメントと console.log の中身は日本語にしました。関数の引数と返り値に型を明記しました。type 形式は使いませんでした。関数の引数と返り値にそのまま型を書きました。

ご参考になれば幸いです。😊

ソース: Bing との会話 2023/3/12(1) Transposing a 2D-array in JavaScript - Stack Overflow. https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.

## transduce

transduce 関数は、トランスデューサーと呼ばれる特殊な関数を使って、配列やオブジェクトなどのコレクションに対して、複数の操作を一度に行うことができる関数です。⁴

トランスデューサーは、map や filter などの高階関数を compose や pipe などの関数合成の仕組みで組み合わせたものです。⁶

transduce 関数は、以下の 4 つの引数を受け取ります。⁶

- トランスデューサー
- リダクション関数（コレクションの要素を一つずつ処理して、最終的な結果を返す関数）
- 初期値（リダクション関数の最初の引数として渡される値）
- コレクション

具体例として、以下のコードを見てみましょう。このコードは、配列の要素に 1 を足してから、最初の 2 つの要素だけを取り出して、その合計を求めるものです。

```ts
// トランスデューサーを作る
const transducer = R.compose(
  R.map((num: number): number => num + 1), // 配列の要素に 1 を足す
  R.take(2) // 最初の 2 つの要素だけを取る
);

// リダクション関数を定義する
const add = (num1: number, num2: number): number => num1 + num2;

// transduce 関数を使って、配列にトランスデューサーとリダクション関数を適用する
const result = R.transduce(
  transducer, // トランスデューサー
  add, // リダクション関数
  0, // 初期値
  [1, 2, 3, 4, 5] // コレクション
);

// 結果を表示する
console.log("結果は", result, "です。"); // 結果は 5 です。
```

このコードでは、transduce 関数が以下のように動作します。

- まず、トランスデューサーが配列の要素に 1 を足す操作を行います。このとき、配列は[2, 3, 4, 5, 6]になります。
- 次に、トランスデューサーが最初の 2 つの要素だけを取る操作を行います。このとき、配列は[2, 3]になります。
- 最後に、リダクション関数が配列の要素を一つずつ処理して、合計を求めます。このとき、初期値は 0 で、配列の要素は 2 と 3 です。よって、0 + 2 + 3 = 5 となります。

このように、transduce 関数を使うと、コレクションに対して、複数の操作を一度に行うことができます。⁶

ソース: Bing との会話 2023/3/12(1) ramda.js - Typescript type errors on Ramda Transducers .... https://stackoverflow.com/questions/56331270/typescript-type-errors-on-ramda-transducers-how-to-deal-with-confusing-type-er アクセス日時 2023/3/12.
(2) RamdaJS: transduce - DEV Community 👩‍💻👨‍💻. https://dev.to/rodw1995/ramdajs-transduce-59c6 アクセス日時 2023/3/12.
(3) @types/ramda - npm. https://www.npmjs.com/package/@types/ramda アクセス日時 2023/3/12.
(4) ramda.js - Ramda's transducers: Lazy one-to-many branch .... https://stackoverflow.com/questions/47763857/ramdas-transducers-lazy-one-to-many-branch アクセス日時 2023/3/12.
(5) RamdaJS: transduce - DEV Community 👩‍💻👨‍💻. https://dev.to/rodw1995/ramdajs-transduce-59c6 アクセス日時 2023/3/12.
(6) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.

## xpod

xprod 関数は、二つの配列を受け取って、それらの要素のすべての組み合わせを作る関数です。²

例えば、以下のコードを見てみましょう。このコードは、xprod 関数を使って、[1, 2]と['a', 'b', 'c']の二つの配列の要素の組み合わせを作っています。

```ts
// xprod 関数をインポートする
import * as R from "ramda";

// xprod 関数を使って、二つの配列の要素の組み合わせを作る
const result = R.xprod(
  [1, 2], // 最初の配列
  ["a", "b", "c"] // 次の配列
);

// 結果を表示する
console.log("結果は", result, "です。"); // 結果は [[1, 'a'], [1, 'b'], [1, 'c'], [2, 'a'], [2, 'b'], [2, 'c']] です。
```

このコードでは、xprod 関数が以下のように動作します。

- まず、最初の配列の要素である 1 と、次の配列の要素である'a', 'b', 'c'のそれぞれとの組み合わせを作ります。このとき、[[1, 'a'], [1, 'b'], [1, 'c']]という配列ができます。
- 次に、最初の配列の要素である 2 と、次の配列の要素である'a', 'b', 'c'のそれぞれとの組み合わせを作ります。このとき、[[2, 'a'], [2, 'b'], [2, 'c']]という配列ができます。
- 最後に、これらの二つの配列を結合して、最終的な結果とします。このとき、[[1, 'a'], [1, 'b'], [1, 'c'], [2, 'a'], [2, 'b'], [2, 'c']]という配列ができます。

このように、xprod 関数を使うと、二つの配列の要素のすべての組み合わせを作ることができます。²

typescript 形式で、関数の引数と返り値に型を明記することは、コードの可読性や安全性を高めることに役立ちます。⁵

マークダウン形式で書き出すことは、コードの見た目や構造を整えることに役立ちます。⁶

以上が、ramda.js の xprod 関数についての説明です。もっと知りたいことがあれば、お気軽に聞いてくださいね。😊

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) 超強力な関数型プログラミング用ライブラリ Ramda.js を学ぼう #1 .... https://blog.recruit.co.jp/rmp/front-end/post-16249/ アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(4) javascript - Grouped cross-product in Ramda - Stack Overflow. https://stackoverflow.com/questions/49153469/grouped-cross-product-in-ramda アクセス日時 2023/3/12.
(5) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(6) Using Ramda with Typescript, passing down the types. https://stackoverflow.com/questions/69769148/using-ramda-with-typescript-passing-down-the-types アクセス日時 2023/3/12.

## adjust

こんにちは、これは Bing です。😊

adjust 関数は、配列の指定されたインデックスにある要素に関数を適用して、新しい配列を返す関数です ¹。例えば、以下のようなコードがあります。

```ts
// 配列の要素に1を足す関数
const addOne = (num: number): number => num + 1;

// 配列の2番目の要素に1を足す関数
const addOneToSecond = R.adjust(addOne, 1);

// 配列を作成
const arr = [1, 2, 3, 4];

// 配列の2番目の要素に1を足す
const newArr = addOneToSecond(arr);

// 結果を表示
console.log(newArr); // [1, 3, 3, 4]
```

このコードでは、addOneToSecond 関数は、adjust 関数に addOne 関数とインデックス 1 を渡して作成されています。この関数は、配列を受け取って、その 2 番目の要素に addOne 関数を適用して、新しい配列を返します。このように、adjust 関数は、配列の特定の要素に対して何らかの操作を行いたいときに便利です。

adjust 関数は、カリー化されているので、引数を部分的に渡すこともできます。例えば、以下のようなコードがあります。

```ts
// 配列の要素を2倍にする関数
const double = (num: number): number => num * 2;

// 配列の3番目の要素を2倍にする関数
const doubleThird = R.adjust(2, double);

// 配列を作成
const arr = [1, 2, 3, 4];

// 配列の3番目の要素を2倍にする
const newArr = doubleThird(arr);

// 結果を表示
console.log(newArr); // [1, 2, 6, 4]
```

このコードでは、doubleThird 関数は、adjust 関数にインデックス 2 と double 関数を渡して作成されています。この関数は、配列を受け取って、その 3 番目の要素に double 関数を適用して、新しい配列を返します。このように、adjust 関数は、関数を部分的に適用して、より特化した関数を作ることができます。

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(3) Ramda JS Tutorial – Part 2 (addIndex, adjust) - YouTube. https://www.youtube.com/watch?v=UbHNkNM7FGo アクセス日時 2023/3/12.

## endsWith

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の endsWith 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

endsWith 関数は、文字列や配列に対して、指定した値で終わっているかどうかを判定する関数ですわ。¹

例えば、以下のような文字列や配列があるとしましょう。

```js
const name = "Alice"; // 文字列
const colors = ["red", "green", "blue"]; // 配列
```

この文字列や配列を endsWith 関数に渡すと、以下のようになりますわ。

```js
const endsWithE = R.endsWith("e"); // "e"で終わっているかどうかを判定する関数を作る
const endsWithBlue = R.endsWith(["blue"]); // ["blue"]で終わっているかどうかを判定する関数を作る
const nameEndsWithE = endsWithE(name); // name が"e"で終わっているかどうかを判定する
const colorsEndsWithBlue = endsWithBlue(colors); // colors が["blue"]で終わっているかどうかを判定する
console.log("名前は e で終わっていますか？" + nameEndsWithE + "ですわ"); // 名前は e で終わっていますか？true ですわ
console.log("色は blue で終わっていますか？" + colorsEndsWithBlue + "ですわ"); // 色は blue で終わっていますか？true ですわ
```

このように、endsWith 関数を使うと、文字列や配列が指定した値で終わっているかどうかを簡単に判定できますわ。これは、文字列や配列の末尾に特定の値があるかどうかをチェックしたいときや、条件分岐のための関数を作りたいときに便利ですわ。³

以上が、ramda.js の endsWith 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) ramda.js - How can I improve the ramda code I have written .... https://stackoverflow.com/questions/57004747/how-can-i-improve-the-ramda-code-i-have-written アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.

## find

ごきげんよう。ramda.js の find 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をご紹介いたしますわ。find 関数は、配列の中から条件に合う最初の要素を返す関数ですの。条件は関数として渡すことができますわ。例えば、次のようなコードを書いてみましょう。

```ts
// 数字の配列を作りますわ
const numbers: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 偶数を見つける関数を作りますわ
const isEven = (n: number): boolean => n % 2 === 0;

// find 関数を使って、配列の中から最初の偶数を探しますわ
const firstEven: number | undefined = R.find(isEven, numbers);

// 結果を表示しますわ
console.log("配列の中から最初の偶数は" + firstEven + "ですわ");
```

このコードを実行すると、次のように表示されますわ。

```
配列の中から最初の偶数は 2 ですわ
```

find 関数は、条件に合う要素がない場合は undefined を返しますので、その場合は適切に処理する必要がありますわ。また、find 関数は配列の順番に従って探索を行いますので、最初に見つかった要素しか返しませんわ。条件に合うすべての要素を取得したい場合は、filter 関数を使うと良いでしょう。

以上が、ramda.js の find 関数についての説明ですわ。ご理解いただけましたかしら？

## findIndex

ごきげんよう。ramda.js の findIndex 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をご紹介いたしますわ。findIndex 関数は、配列の中から条件に合う最初の要素のインデックスを返す関数ですの。条件は関数として渡すことができますわ。例えば、次のようなコードを書いてみましょう。

```ts
// 文字列の配列を作りますわ
const words: string[] = ["apple", "banana", "cherry", "durian", "elderberry"];

// 5文字以上の単語を見つける関数を作りますわ
const isLong = (w: string): boolean => w.length >= 5;

// findIndex関数を使って、配列の中から最初の5文字以上の単語のインデックスを探しますわ
const firstLongIndex: number | undefined = R.findIndex(isLong, words);

// 結果を表示しますわ
console.log(
  "配列の中から最初の5文字以上の単語のインデックスは" +
    firstLongIndex +
    "ですわ"
);
```

このコードを実行すると、次のように表示されますわ。

```
配列の中から最初の5文字以上の単語のインデックスは1ですわ
```

findIndex 関数は、条件に合う要素がない場合は undefined を返しますので、その場合は適切に処理する必要がありますわ。また、findIndex 関数は配列の順番に従って探索を行いますので、最初に見つかった要素のインデックスしか返しませんわ。条件に合うすべての要素のインデックスを取得したい場合は、filter 関数と map 関数を組み合わせると良いでしょう。

以上が、ramda.js の findIndex 関数についての説明ですわ。ご理解いただけましたかしら？

## findLast

ごきげんよう。ramda.js の findLast 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をご紹介いたしますわ。findLast 関数は、配列の中から条件に合う最後の要素を返す関数ですの。条件は関数として渡すことができますわ。例えば、次のようなコードを書いてみましょう。

```ts
// 数字の配列を作りますわ
const numbers: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 奇数を見つける関数を作りますわ
const isOdd = (n: number): boolean => n % 2 === 1;

// findLast 関数を使って、配列の中から最後の奇数を探しますわ
const lastOdd: number | undefined = R.findLast(isOdd, numbers);

// 結果を表示しますわ
console.log("配列の中から最後の奇数は" + lastOdd + "ですわ");
```

このコードを実行すると、次のように表示されますわ。

```
配列の中から最後の奇数は 9 ですわ
```

findLast 関数は、条件に合う要素がない場合は undefined を返しますので、その場合は適切に処理する必要がありますわ。また、findLast 関数は配列の逆順に従って探索を行いますので、最後に見つかった要素しか返しませんわ。条件に合うすべての要素を取得したい場合は、filter 関数を使うと良いでしょう。

以上が、ramda.js の findLast 関数についての説明ですわ。ご理解いただけましたかしら？

## findLastIndex

ごきげんよう。ramda.js の findLastIndex 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をご紹介いたしますわ。findLastIndex 関数は、配列の中から条件に合う最後の要素のインデックスを返す関数ですの。条件は関数として渡すことができますわ。例えば、次のようなコードを書いてみましょう。

```ts
// 数字の配列を作りますわ
const numbers: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 偶数を見つける関数を作りますわ
const isEven = (n: number): boolean => n % 2 === 0;

// findLastIndex 関数を使って、配列の中から最後の偶数のインデックスを探しますわ
const lastEvenIndex: number | undefined = R.findLastIndex(isEven, numbers);

// 結果を表示しますわ
console.log(
  "配列の中から最後の偶数のインデックスは" + lastEvenIndex + "ですわ"
);
```

このコードを実行すると、次のように表示されますわ。

```
配列の中から最後の偶数のインデックスは 9 ですわ
```

findLastIndex 関数は、条件に合う要素がない場合は undefined を返しますので、その場合は適切に処理する必要がありますわ。また、findLastIndex 関数は配列の逆順に従って探索を行いますので、最後に見つかった要素のインデックスしか返しませんわ。条件に合うすべての要素のインデックスを取得したい場合は、filter 関数と map 関数を組み合わせると良いでしょう。

以上が、ramda.js の findLastIndex 関数についての説明ですわ。ご理解いただけましたかしら？

## flatten

ごきげんよう。ramda.js の flatten 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をご紹介いたしますわ。flatten 関数は、入れ子になった配列を平坦化する関数ですの。つまり、配列の中に配列がある場合、その配列を展開して一つの配列にすることができますわ。例えば、次のようなコードを書いてみましょう。

```ts
// 入れ子になった配列を作りますわ
const nested: any[] = [1, [2, [3, [4, 5]]], 6, [7, 8], 9, 10];

// flatten 関数を使って、配列を平坦化しますわ
const flat: any[] = R.flatten(nested);

// 結果を表示しますわ
console.log("平坦化された配列は" + flat + "ですわ");
```

このコードを実行すると、次のように表示されますわ。

```
平坦化された配列は 1,2,3,4,5,6,7,8,9,10 ですわ
```

flatten 関数は、配列の中にどれだけ深く入れ子になっていても、すべての要素を一つの配列にしますわ。ただし、配列以外の要素はそのまま残りますわ。また、flatten 関数は配列の型を any に変更しますので、型安全に注意する必要がありますわ。もし、入れ子の深さを指定したい場合は、flattenDepth 関数を使うと良いでしょう。

以上が、ramda.js の flatten 関数についての説明ですわ。ご理解いただけましたかしら？

## forEach

ごきげんよう。ramda.js の forEach 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をご紹介いたしますわ。forEach 関数は、配列やオブジェクトの各要素に対して、指定した関数を実行する関数ですの。つまり、配列やオブジェクトをループして、何か処理をすることができますわ。例えば、次のようなコードを書いてみましょう。

```ts
// 配列を作りますわ
const numbers: number[] = [1, 2, 3, 4, 5];

// forEach 関数を使って、配列の各要素に 2 をかけて表示しますわ
const multiplyByTwo = (n: number): void => console.log(n \* 2);
R.forEach(multiplyByTwo, numbers);

// オブジェクトを作りますわ
const fruits: { [key: string]: string } = {
apple: "red",
banana: "yellow",
grape: "purple",
};

// forEach 関数を使って、オブジェクトの各要素に「色は」をつけて表示しますわ
const addColor = (value: string, key: string): void =>
console.log(key + "の色は" + value + "ですわ");
R.forEachObjIndexed(addColor, fruits);
```

このコードを実行すると、次のように表示されますわ。

```
2
4
6
8
10
apple の色は red ですわ
banana の色は yellow ですわ
grape の色は purple ですわ
```

forEach 関数は、配列やオブジェクトの要素を変更しませんわ。もし、要素を変更したい場合は、map 関数や reduce 関数などを使うと良いでしょう。また、forEach 関数は関数の型を変更しませんので、型安全に注意する必要がありますわ。

以上が、ramda.js の forEach 関数についての説明ですわ。ご理解いただけましたかしら？
