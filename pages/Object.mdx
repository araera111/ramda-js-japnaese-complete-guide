---
title: "Object"
---

Object では Object に関する関数を紹介。現在 9 個。

import { Callout } from "nextra-theme-docs";

## assoc

オブジェクトに key, value を追加する関数です。  
カリー化されているので後回しにできるのが便利です。  
あと再代入をしないので、もとのオブジェクトに影響しないのもいいね！

```ts
import { assoc } from "ramda";

const user = { id: 1 };
const user2 = { id: 2 };
const user3 = { id: 3 };

/* カリー化した場合 */
const addNameUser = assoc("name", "TANAKA")(user);
console.log(addNameUser); // { id: 1, name: 'TANAKA' }

/* 3つ引数を渡す場合 */
const addNameUser2 = assoc("name", "YAMADA", user2);
console.log(addNameUser2); // { id: 2, name: 'YAMADA' }

/* ramdaを使わないならこんな感じ */
const addNameuser3 = { ...user3, name: "HIRAYAMA" };
console.log(addNameuser3); // { id: 3, name: 'HIRAYAMA' }
```

<Callout type="warning" emoji="⚠️" style={{"white-space": "pre-wrap;"}}>
<div >
注意：型は補完されない  
本来、USER 型は address などというプロパティはないが、assoc なら追加できてしまう。  
プロパティを追加するのは assoc で良いが、変更するならスプレッド構文でコピーするか、immer などを使うと良い。
</div>
</Callout>
```ts
type User = {
  id: number;
  name: string;
};
const user4 = { id: 4, name: "ISHIDA" };
const newUser: User = assoc("address", "京都府京都市駅前1丁目1-1-1", user4);
console.log({ newUser }); // { newUser: { id: 4, name: 'ISHIDA', address: '京都府京都市駅前1丁目1-1-1' } }
```

## prop

引数 1 にオブジェクトのキー、引数 2 にオブジェクトを渡す。  
そうするとそのキーのバリューが取ってこられる関数です。  
ramda だといろいろな関数で prop を使います。

```ts
R.prop("x", { x: 100 }); //=> 100
R.prop("x", {}); //=> undefined
R.prop(0, [100]); //=> 100
R.compose(R.inc, R.prop("x"))({ x: 3 }); //=> 4
```

## clone

オブジェクトをディープコピーしてくれる関数です。  
下記例、shallowCopy 関数はスプレッド構文を使用してシャローコピーをしています。  
コピーした obj2 のプロパティにある posts のなかにある post の title を変えました。  
そうすると、コピー元の obj のほうも posts の index0 にある post の title が変わってしまいます。

deepCopy 関数では ramda.js の clone 関数を使用しました。  
そうすると、同じように obj2 のプロパティを変更しても obj のほうには影響がありません。

このようにネストしたオブジェクトを安全にコピーできます。  
ただ、ディープコピーは重い処理です。本当に必要なとき以外はシャローコピーで十分かもしれません。

```ts
import { clone } from "ramda";

const shallowCopy = () => {
  const post = { id: 1, title: "ご挨拶" };
  const obj = { id: 1, name: "TANAKA", posts: [post] };
  const obj2 = { ...obj };
  if (obj2.posts[0] === undefined) return;
  obj2.posts[0].title = "ご挨拶(修正版)";
  console.log(obj2); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶(修正版)' } ] }
  console.log(obj); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶(修正版)' } ] } ←変わってしまった！
};
shallowCopy();

const deepCopy = () => {
  const post = { id: 1, title: "ご挨拶" };
  const obj = { id: 1, name: "TANAKA", posts: [post] };
  const obj2 = clone(obj);
  if (obj2.posts[0] === undefined) return;
  obj2.posts[0].title = "ご挨拶(修正版)";
  console.log(obj2); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶(修正版)' } ] }
  console.log(obj); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶' } ] } ←変わってない！
};
deepCopy();
```

## dissoc

これは assoc がわかれば簡単なので、公式の例を拝借。  
asssoc の逆。  
第一引数に Object の key を取り、その key:value を Object から削除する。

```ts
dissoc("b", { a: 1, b: 2, c: 3 }); //=> {a: 1, c: 3}
```

## dissocPath

これは assocPath がわかれば簡単  
shallowCopy らしい

```ts
/* aのなかのbのなかのcを消す */
R.dissocPath(["a", "b", "c"], { a: { b: { c: 42 } } }); //=> {a: {b: {}}}
```

## values

Object の value だけを取ってくる関数。

```ts
values({ a: 1, b: 2, c: 3 }); //=> [1, 2, 3]
```

## keys

Object の key だけを取ってくる関数。

```ts
keys({ a: 1, b: 2, c: 3 }); //=> ['a', 'b', 'c']
```

## toPairs

Object の key と value を配列に入れてくれる関数。  
Object を配列的に処理したいときに使うかな……。
key と value をタプルにしてくれる、みたいな感じ。

```ts
toPairs({ a: 1, b: 2, c: 3 }); //=> [['a', 1], ['b', 2], ['c', 3]]
```

## assocPath

assoc の path(key の nest)を配列でできる。  
引数 1 がオブジェクトのパスの string[]  
引数 2 が値
引数 3 がもとのオブジェクト

```ts
/* aのなかのbのなかのcに42という値を与えたい */
R.assocPath(["a", "b", "c"], 42, { a: { b: { c: 0 } } }); //=> {a: {b: {c: 42}}}

// Any missing or non-object keys in path will be overridden
/* bとかcがないときは追加される */
R.assocPath(["a", "b", "c"], 42, { a: 5 }); //=> {a: {b: {c: 42}}}
```

## toPairsIn

```
typescript
const obj = {
a: 1,
b: 2,
c: 3
};

// obj のプロトタイプに d というプロパティを追加する
Object.prototype.d = 4;

// toPairsIn 関数の型は、
// (obj: object) => [string, any][]
// となります。
// obj はオブジェクト型、返り値は文字列と任意の型のペアの配列型です。

// toPairsIn 関数を obj に適用すると、
// [[a, 1], [b, 2], [c, 3], [d, 4]]
// という配列が返ります。
// 継承された d プロパティも含まれています。
const result = R.toPairsIn(obj);

// 結果をコンソールに出力する
console.log("obj のすべてのプロパティを[key, value]のペアに変換した結果は、");
console.log(result);
```

このように、toPairsIn 関数はオブジェクトのプロパティをペアに変換する関数です。もっと知りたいことがありますか？

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(3) toPairs and toPairsIn functions | Ramda JS Tutorials - YouTube. https://www.youtube.com/watch?v=USwrZkubf0M アクセス日時 2023/3/12.

## eqProps

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の eqProps 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

eqProps 関数は、二つのオブジェクトに対して、指定したプロパティの値が等しいかどうかを判定する関数ですわ。¹

例えば、以下のようなオブジェクトがあるとしましょう。

```js
const alice = { name: "Alice", age: 20, hair: "blonde" }; // Alice という名前で 20 歳でブロンドの髪のオブジェクト
const bob = { name: "Bob", age: 20, hair: "brown" }; // Bob という名前で 20 歳でブラウンの髪のオブジェクト
const charlie = { name: "Charlie", age: 25, hair: "blonde" }; // Charlie という名前で 25 歳でブロンドの髪のオブジェクト
```

このオブジェクトを eqProps 関数に渡すと、以下のようになりますわ。

```js
const eqByAge = R.eqProps("age"); // age プロパティの値が等しいかどうかを判定する関数を作る
const aliceAndBob = eqByAge(alice, bob); // alice と bob の age プロパティの値が等しいかどうかを判定する
const aliceAndCharlie = eqByAge(alice, charlie); // alice と charlie の age プロパティの値が等しいかどうかを判定する
console.log("Alice と Bob は同じ年齢ですか？" + aliceAndBob + "ですわ"); // Alice と Bob は同じ年齢ですか？true ですわ
console.log("Alice と Charlie は同じ年齢ですか？" + aliceAndCharlie + "ですわ"); // Alice と Charlie は同じ年齢ですか？false ですわ
```

このように、eqProps 関数を使うと、二つのオブジェクトに対して、任意のプロパティの値が等しいかどうかを簡単に判定できますわ。これは、オブジェクトの特定のプロパティを比較したいときに便利ですわ。³

以上が、ramda.js の eqProps 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/0.9/docs/ アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.

## evolve

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の evolve 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

evolve 関数は、オブジェクトのプロパティに対して、変換関数を適用して新しいオブジェクトを作る関数ですわ。²

例えば、以下のようなオブジェクトがあるとしましょう。

```js
const person = {
  name: "Alice",
  age: 20,
  hobbies: ["reading", "writing", "singing"],
}; // Alice という名前で 20 歳で趣味が読書と執筆と歌唱のオブジェクト
```

このオブジェクトを evolve 関数に渡すと、以下のようになりますわ。

```js
const transform = {
  // 変換関数を定義するオブジェクト
  name: R.toUpper, // name プロパティには大文字にする関数を適用する
  age: R.add(1), // age プロパティには 1 を足す関数を適用する
  hobbies: R.append("dancing"), // hobbies プロパティにはダンスを追加する関数を適用する
};
const newPerson = R.evolve(transform, person); // evolve 関数に変換関数と元のオブジェクトを渡す
console.log("変換前のオブジェクトは" + JSON.stringify(person) + "ですわ"); // 変換前のオブジェクトは{"name":"Alice","age":20,"hobbies":["reading","writing","singing"]}ですわ
console.log("変換後のオブジェクトは" + JSON.stringify(newPerson) + "ですわ"); // 変換後のオブジェクトは{"name":"ALICE","age":21,"hobbies":["reading","writing","singing","dancing"]}ですわ
```

このように、evolve 関数を使うと、オブジェクトのプロパティに対して、任意の変換関数を適用して新しいオブジェクトを作ることができますわ。これは、オブジェクトの特定のプロパティを変更したいときに便利ですわ。²

以上が、ramda.js の evolve 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) javascript - ramda evolve function example - Stack Overflow. https://stackoverflow.com/questions/42135771/ramda-evolve-function-example アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.

## forEachObjIndexed

ごきげんよう。ramda.js の forEachObjIndexed 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をご紹介いたしますわ。forEachObjIndexed 関数は、オブジェクトの各要素に対して、指定した関数を実行する関数ですの。つまり、オブジェクトをループして、何か処理をすることができますわ。forEach 関数との違いは、関数にはオブジェクトの値だけでなく、キーも渡されることですわ。例えば、次のようなコードを書いてみましょう。

```ts
// オブジェクトを作りますわ
const animals: { [key: string]: string } = {
  dog: "woof",
  cat: "meow",
  cow: "moo",
};

// forEachObjIndexed 関数を使って、オブジェクトの各要素に「と鳴く」をつけて表示しますわ
const addSound = (value: string, key: string): void =>
  console.log(key + "は" + value + "と鳴きますわ");
R.forEachObjIndexed(addSound, animals);
```

このコードを実行すると、次のように表示されますわ。

```
dog は woof と鳴きますわ
cat は meow と鳴きますわ
cow は moo と鳴きますわ
```

forEachObjIndexed 関数は、オブジェクトの要素を変更しませんわ。もし、要素を変更したい場合は、mapObjIndexed 関数や reduceObjIndexed 関数などを使うと良いでしょう。また、forEachObjIndexed 関数は関数の型を変更しませんので、型安全に注意する必要がありますわ。

以上が、ramda.js の forEachObjIndexed 関数についての説明ですわ。ご理解いただけましたかしら？

## has

ごきげんよう、これは Bing です。ramda.js の has 関数についてお教えしますわ。has 関数は、オブジェクトに特定のプロパティが存在するかどうかを真偽値で返す関数です ²。例えば、次のように使うことができますわ。

```ts
// has 関数を使って、オブジェクトに name プロパティが存在するかどうかを判定する
const obj: { name: string; age: number } = { name: "Alice", age: 20 };
const result: boolean = R.has("name", obj);

// 結果を確認する
console.log(result); // true
```

この関数は、自動的にカリー化されているので、一つの引数だけを渡すと、新しい関数を返しますわ。例えば、次のようにすることができますわ。

```ts
// has 関数に name を渡して、新しい関数を作る
const hasName: (obj: any) => boolean = R.has("name");

// 新しい関数にオブジェクトを渡して、name プロパティが存在するかどうかを判定する
const obj: { name: string; age: number } = { name: "Alice", age: 20 };
const result: boolean = hasName(obj);

// 結果を確認する
console.log(result); // true
```

このように、has 関数は、オブジェクトに特定のプロパティが存在するかどうかを真偽値で返すことができますわ。ramda.js についてもっと知りたい場合は、公式サイト ² やドキュメント ³ をご覧になってくださいませ。⁴ も参考になるかもしれませんわね。以上が、has 関数の具体例と実用的な使用方法ですわ。ご理解いただけましたか？もっと勉強してくださいませね。

ソース: Bing との会話 2023/3/13(1) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.
(4) 超強力な関数型プログラミング用ライブラリ Ramda.js を学ぼう #1 .... https://blog.recruit.co.jp/rmp/front-end/post-16249/ アクセス日時 2023/3/13.

## hasIn

ごきげんよう、これは Bing です。ramda.js の hasIn 関数についてお教えしますわ。hasIn 関数は、オブジェクトに特定のプロパティが存在するかどうかを真偽値で返す関数ですが、has 関数と違って、プロトタイプチェーンを辿って探しますわ ²。例えば、次のように使うことができますわ。

```ts
// hasIn関数を使って、オブジェクトにtoStringプロパティが存在するかどうかを判定する
const obj: { name: string; age: number } = { name: "Alice", age: 20 };
const result: boolean = R.hasIn("toString", obj);

// 結果を確認する
console.log(result); // true
```

この関数も、自動的にカリー化されているので、一つの引数だけを渡すと、新しい関数を返しますわ。例えば、次のようにすることができますわ。

```ts
// hasIn関数にtoStringを渡して、新しい関数を作る
const hasToString: (obj: any) => boolean = R.hasIn("toString");

// 新しい関数にオブジェクトを渡して、toStringプロパティが存在するかどうかを判定する
const obj: { name: string; age: number } = { name: "Alice", age: 20 };
const result: boolean = hasToString(obj);

// 結果を確認する
console.log(result); // true
```

このように、hasIn 関数は、オブジェクトに特定のプロパティが存在するかどうかを真偽値で返すことができますわ。ただし、プロトタイプチェーンを辿って探すので、has 関数よりも遅くなる可能性がありますわ。ramda.js についてもっと知りたい場合は、公式サイト ¹ やドキュメント ² をご覧になってくださいませ。³ も参考になるかもしれませんわね。以上が、hasIn 関数の具体例と実用的な使用方法ですわ。ご理解いただけましたか？もっと勉強してくださいませね。

ソース: Bing との会話 2023/3/13(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.

## hasPath

ごきげんよう、これは Bing です。ramda.js の hasPath 関数についてお教えしますわ。hasPath 関数は、オブジェクトに特定のパスに沿ったプロパティが存在するかどうかを真偽値で返す関数ですわ。例えば、次のように使うことができますわ。

```ts
// hasPath 関数を使って、オブジェクトに a.b.c プロパティが存在するかどうかを判定する
const obj: { a: { b: { c: number } } } = { a: { b: { c: 42 } } };
const result: boolean = R.hasPath(["a", "b", "c"], obj);

// 結果を確認する
console.log(result); // true
```

この関数も、自動的にカリー化されているので、一つの引数だけを渡すと、新しい関数を返しますわ。例えば、次のようにすることができますわ。

```ts
// hasPath 関数に["a", "b", "c"]を渡して、新しい関数を作る
const hasABC: (obj: any) => boolean = R.hasPath(["a", "b", "c"]);

// 新しい関数にオブジェクトを渡して、a.b.c プロパティが存在するかどうかを判定する
const obj: { a: { b: { c: number } } } = { a: { b: { c: 42 } } };
const result: boolean = hasABC(obj);

// 結果を確認する
console.log(result); // true
```

このように、hasPath 関数は、オブジェクトに特定のパスに沿ったプロパティが存在するかどうかを真偽値で返すことができますわ。ramda.js についてもっと知りたい場合は、公式サイト ¹ やドキュメント ² をご覧になってくださいませ。³ も参考になるかもしれませんわね。以上が、hasPath 関数の具体例と実用的な使用方法ですわ。ご理解いただけましたか？もっと勉強してくださいませね。

ソース: Bing との会話 2023/3/13(1) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.

## invertObj

ごきげんよう。ramda.js の invertObj 関数について、ご質問いただきましたわね。invertObj 関数は、オブジェクトのキーと値を入れ替えた新しいオブジェクトを生成する関数ですわ。ただし、invertObj 関数は、オブジェクトの値が文字列か数値かシンボルでなければならないという制約がありますわ。それ以外の型の場合には、エラーになりますわ。また、invertObj 関数は、オブジェクトの値が配列の場合には、配列の要素をキーにせず、配列そのものをキーにしますわ。invertObj 関数の使い方を、具体例とともにご説明いたしますわ。

```typescript
// ramda.js の invertObj 関数をインポートする
import { invertObj } from "ramda";

// オブジェクトを用意する
const obj: Record<string, string | number | symbol> = { a: 1, b: 2, c: 3 };

// invertObj 関数にオブジェクトを渡す
const newObj: Record<string | number | symbol, string> = invertObj(obj);

// オブジェクトの内容を確認する
console.log("元のオブジェクトはこうですわ: " + JSON.stringify(obj)); // 元のオブジェクトはこうですわ: {"a":1,"b":2,"c":3}
console.log(
  "キーと値を入れ替えたオブジェクトはこうですわ: " + JSON.stringify(newObj)
); // キーと値を入れ替えたオブジェクトはこうですわ: {"1":"a","2":"b","3":"c"}
```

このように、invertObj 関数は、オブジェクトのキーと値を入れ替えた新しいオブジェクトを生成できますわ。ただし、注意しなければならないのは、invertObj 関数は、オブジェクトの値が文字列か数値かシンボルでなければならないということですわ。例えば、次のように書くと、エラーになりますわ。

```typescript
// ramda.js の invertObj 関数をインポートする
import { invertObj } from "ramda";

// オブジェクトを用意する
const obj: Record<string, any> = { a: { x: 1, y: 2 }, b: { z: 3 } };

// invertObj 関数にオブジェクトを渡す
const newObj: Record<any, string> = invertObj(obj); // Error: Cannot convert object to primitive value

// オブジェクトの内容を確認する
console.log("元のオブジェクトはこうですわ: " + JSON.stringify(obj)); // 元のオブジェクトはこうですわ: {"a":{"x":1,"y":2},"b":{"z":3}}
console.log(
  "キーと値を入れ替えたオブジェクトはこうですわ: " + JSON.stringify(newObj)
); // キーと値を入れ替えたオブジェクトはこうですわ: Error: Cannot convert object to primitive value
```

このように、invertObj 関数は、オブジェクトの値がオブジェクトの場合には、使えませんわ。この場合には、別の方法を考えなければなりませんわ。また、invertObj 関数は、オブジェクトの値が配列の場合には、配列そのものをキーにしますわ。例えば、次のように書くと、次のようになりますわ。

```typescript
// ramda.jsのinvertObj関数をインポートする
import { invertObj } from "ramda";

// オブジェクトを用意する
const obj: Record<string, string | number | symbol | any[]> = {
  a: [1, 2, 3],
  b: [4, 5],
  c: [6],
};

// invertObj関数にオブジェクトを渡す
const newObj: Record<string | number | symbol | any[], string> = invertObj(obj);

// オブジェクトの内容を確認する
console.log("元のオブジェクトはこうですわ: " + JSON.stringify(obj)); // 元のオブジェクトはこうですわ: {"a":[1,2,3],"b":[4,5],"c":[6]}
console.log(
  "キーと値を入れ替えたオブジェクトはこうですわ: " + JSON.stringify(newObj)
); // キーと値を入れ替えたオブジェクトはこうですわ: {"1,2,3":"a","4,5":"b","6":"c"}
```

このように、invertObj 関数は、オブジェクトの値が配列の場合には、配列そのものをキーにして、元のキーを値にした新しいオブジェクトを生成できますわ。ただし、配列の要素をキーにしたい場合には、invertObj 関数ではなく、invert 関数を使う必要がありますわ。invert 関数については、別の質問でお答えいたしましたわ。invertObj 関数の使い方について、お分かりになりましたでしょうか？もし、まだご不明な点がございましたら、お気軽にお尋ねくださいませ。 を参考にして、お答えいたしましたわ。ご満足いただけましたら、幸いですわ。では、またお会いしましょう。ごきげんよう。🎀

## keysIn

ごきげんよう、お嬢様。ramda.js の keysIn 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。keysIn 関数は、オブジェクトを受け取って、そのオブジェクトの自身のプロパティと継承されたプロパティの名前を配列にして返す関数ですの。¹ 例えば、以下のようなオブジェクトがあるとしますわ。

```typescript
type Person = {
  name: string;
  age: number;
};

type Student = Person & {
  grade: number;
};

const alice: Student = {
  name: "Alice",
  age: 18,
  grade: 3,
};
```

このオブジェクトに keysIn 関数を適用すると、以下のようになりますわ。

```typescript
const keys = keysIn(alice);
console.log(keys); // ["name", "age", "grade"]と表示されますわ
```

keysIn 関数は、オブジェクトのプロパティを列挙したいときに便利ですわ。例えば、オブジェクトのプロパティと値をペアにして表示したいときは、以下のように書けますわ。

```typescript
const showPairs = (obj: object): void => {
  const keys = keysIn(obj);
  keys.forEach((key) => {
    console.log(`${key}: ${obj[key]}`); // プロパティと値を表示しますわ
  });
};

showPairs(alice); // name: Alice, age: 18, grade: 3 と表示されますわ
```

keysIn 関数は、ramda.js の便利な関数の一つですわ。ramda.js は、関数型プログラミングをサポートするライブラリですの。¹ お嬢様は、ramda.js を使って何を作りたいですか？

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.

## lens

ごきげんよう、お嬢様。ramda.js の lens 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。lens 関数は、オブジェクトの一部に注目して、その一部を読み書きするための関数を作る関数ですの。¹ lens 関数は、オブジェクトの形に依存しないロジックを書くのに役立ちますわ。lens 関数は、getter 関数と setter 関数を受け取って、レンズと呼ばれるオブジェクトを返しますわ。¹ 例えば、以下のようなオブジェクトがあるとしますわ。

```typescript
type Person = {
  name: string;
  age: number;
  address: {
    city: string;
    zip: string;
  };
};

const alice: Person = {
  name: "Alice",
  age: 25,
  address: {
    city: "Tokyo",
    zip: "100-0000",
  },
};
```

このオブジェクトの name プロパティに注目するレンズを作るには、以下のように書けますわ。

```typescript
const nameLens = lens(
  (person: Person): string => person.name, // getter 関数
  (name: string, person: Person): Person => ({ ...person, name }) // setter 関数
);
```

このレンズを使って、name プロパティを読み書きするには、view 関数や set 関数や over 関数などを使いますわ。¹ 例えば、以下のように書けますわ。

```typescript
const name = view(nameLens, alice); // Alice と表示されますわ
console.log(name);

const bob = set(nameLens, "Bob", alice); // name プロパティを Bob に変更した新しいオブジェクトを返しますわ
console.log(bob);

const upperCase = over(nameLens, toUpper, alice); // name プロパティを大文字に変更した新しいオブジェクトを返しますわ
console.log(upperCase);
```

lens 関数は、オブジェクトの一部にアクセスするのに便利ですわ。オブジェクトの形が変わっても、レンズを使えばロジックを変える必要がありませんわ。お嬢様は、lens 関数を使って何をしたいですか？

ソース: Bing との会話 2023/3/14(1) Functional Lenses in Javascript with Ramda - DEV Community. https://dev.to/devinholloway/functional-lenses-in-javascript-with-ramda-4li7 アクセス日時 2023/3/14.
(2) Functional Lenses in Javascript with Ramda - DEV Community. https://dev.to/devinholloway/functional-lenses-in-javascript-with-ramda-4li7 アクセス日時 2023/3/14.
(3) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(5) ramda.js - composing lenses using ramda - Stack Overflow. https://stackoverflow.com/questions/50605190/composing-lenses-using-ramda アクセス日時 2023/3/14.

## lensIndex

ごきげんよう、お嬢様。ramda.js の lensIndex 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。lensIndex 関数は、配列の特定のインデックスに注目するレンズを作る関数ですの。¹ lensIndex 関数は、配列の要素にアクセスするのに役立ちますわ。lensIndex 関数は、インデックスの数値を受け取って、レンズと呼ばれるオブジェクトを返しますわ。¹ 例えば、以下のような配列があるとしますわ。

```typescript
const colors: string[] = ["red", "green", "blue"];
```

この配列の 0 番目の要素に注目するレンズを作るには、以下のように書けますわ。

```typescript
const firstLens = lensIndex(0);
```

このレンズを使って、0 番目の要素を読み書きするには、view 関数や set 関数や over 関数などを使いますわ。¹ 例えば、以下のように書けますわ。

```typescript
const first = view(firstLens, colors); // red と表示されますわ
console.log(first);

const newColors = set(firstLens, "pink", colors); // 0 番目の要素を pink に変更した新しい配列を返しますわ
console.log(newColors);

const upperCase = over(firstLens, toUpper, colors); // 0 番目の要素を大文字に変更した新しい配列を返しますわ
console.log(upperCase);
```

lensIndex 関数は、配列のインデックスにアクセスするのに便利ですわ。配列の長さが変わっても、lensIndex 関数を使えばロジックを変える必要がありませんわ。お嬢様は、lensIndex 関数を使って何をしたいですか？

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) lensProp, lensPath and lensIndex functions | Ramda JS Tutorials. https://www.youtube.com/watch?v=i98Di8yV_3Q アクセス日時 2023/3/14.

## lensPath

ごきげんよう、お嬢様。ramda.js の lensPath 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。lensPath 関数は、オブジェクトの特定のプロパティに注目するレンズを作る関数ですの。¹ lensPath 関数は、オブジェクトのネストされたプロパティにアクセスするのに役立ちますわ。lensPath 関数は、プロパティ名の配列を受け取って、レンズと呼ばれるオブジェクトを返しますわ。² 例えば、以下のようなオブジェクトがあるとしますわ。

```typescript
const user: { name: string; address: { city: string; zipcode: string } } = {
  name: "Alice",
  address: {
    city: "Tokyo",
    zipcode: "100-0000",
  },
};
```

このオブジェクトの address.zipcode プロパティに注目するレンズを作るには、以下のように書けますわ。

```typescript
const zipcodeLens = lensPath(["address", "zipcode"]);
```

このレンズを使って、address.zipcode プロパティを読み書きするには、view 関数や set 関数や over 関数などを使いますわ。² 例えば、以下のように書けますわ。

```typescript
const zipcode = view(zipcodeLens, user); // 100-0000と表示されますわ
console.log(zipcode);

const newUser = set(zipcodeLens, "200-0000", user); // address.zipcodeプロパティを200-0000に変更した新しいオブジェクトを返しますわ
console.log(newUser);

const addPrefix = over(zipcodeLens, (z: string) => "〒" + z, user); // address.zipcodeプロパティに〒を付け加えた新しいオブジェクトを返しますわ
console.log(addPrefix);
```

lensPath 関数は、オブジェクトのネストされたプロパティにアクセスするのに便利ですわ。オブジェクトの構造が変わっても、lensPath 関数を使えばロジックを変える必要がありませんわ。お嬢様は、lensPath 関数を使って何をしたいですか？

ソース: Bing との会話 2023/3/14(1) 超強力な関数型プログラミング用ライブラリ Ramda.js を学ぼう #2 .... https://blog.recruit.co.jp/rmp/front-end/post-16290/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(3) lensProp, lensPath and lensIndex functions | Ramda JS Tutorials. https://www.youtube.com/watch?v=i98Di8yV_3Q アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.

## lensProp

ごきげんよう、お嬢様。ramda.js の lensProp 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。lensProp 関数は、オブジェクトの特定のプロパティに注目するレンズを作る関数ですの。² lensProp 関数は、オブジェクトの単一のプロパティにアクセスするのに役立ちますわ。lensProp 関数は、プロパティ名を受け取って、レンズと呼ばれるオブジェクトを返しますわ。² 例えば、以下のようなオブジェクトがあるとしますわ。

```typescript
const user: { name: string; age: number } = {
  name: "Alice",
  age: 20,
};
```

このオブジェクトの age プロパティに注目するレンズを作るには、以下のように書けますわ。

```typescript
const ageLens = lensProp("age");
```

このレンズを使って、age プロパティを読み書きするには、view 関数や set 関数や over 関数などを使いますわ。² 例えば、以下のように書けますわ。

```typescript
const age = view(ageLens, user); // 20 と表示されますわ
console.log(age);

const newUser = set(ageLens, 21, user); // age プロパティを 21 に変更した新しいオブジェクトを返しますわ
console.log(newUser);

const incrementAge = over(ageLens, (a: number) => a + 1, user); // age プロパティを 1 増やした新しいオブジェクトを返しますわ
console.log(incrementAge);
```

lensProp 関数は、オブジェクトの単一のプロパティにアクセスするのに便利ですわ。オブジェクトの構造が変わっても、lensProp 関数を使えばロジックを変える必要がありませんわ。お嬢様は、lensProp 関数を使って何をしたいですか？

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) 超強力な関数型プログラミング用ライブラリ Ramda.js を学ぼう #2 .... https://blog.recruit.co.jp/rmp/front-end/post-16290/ アクセス日時 2023/3/14.
(3) ramda.js - Multiple props in Ramda lens - Stack Overflow. https://stackoverflow.com/questions/58675473/multiple-props-in-ramda-lens アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.

## mapObjIndexed

ごきげんよう、お嬢様。ramda.js の mapObjIndexed 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えていただきたいとおっしゃいましたね。わたくしはお役に立てて光栄ですわ。😊

ramda.js の mapObjIndexed 関数は、オブジェクトの各プロパティに対して、指定した関数を適用して新しいオブジェクトを返す関数ですわ。¹

例えば、以下のようなオブジェクトがあったとしますわ。

```typescript
const scores = {
  Alice: 80,
  Bob: 90,
  Charlie: 95,
};
```

このオブジェクトの各プロパティに対して、キーと値を結合して文字列にする関数を適用したいとしますわ。その場合は、以下のように書けますわ。

```typescript
import { mapObjIndexed } from "ramda";

// キーと値を結合して文字列にする関数
const joinKeyValue = (value: number, key: string): string => `${key}: ${value}`;

// mapObjIndexed関数を使って新しいオブジェクトを作る
const newScores = mapObjIndexed(joinKeyValue, scores);

// 結果を確認する
console.log(newScores); // { Alice: "Alice: 80", Bob: "Bob: 90", Charlie: "Charlie: 95" }
```

このように、mapObjIndexed 関数はオブジェクトの各プロパティに対して任意の処理を行って新しいオブジェクトを作ることができますわ。²³

ramda.js の mapObjIndexed 関数について、ご理解いただけましたでしょうか？もしもっと詳しく知りたいことがありましたら、どうぞお申し付けくださいませ。🙋‍♀️

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) @ramda/mapobjindexed - npm. https://www.npmjs.com/package/@ramda/mapobjindexed アクセス日時 2023/3/14.
(3) javascript - How can I map over object values using Ramda.js .... https://stackoverflow.com/questions/46086007/how-can-i-map-over-object-values-using-ramda-js-and-take-only-first-element アクセス日時 2023/3/14.

## mergeDeepLeft

ごきげんよう、お嬢様。ramda.js の mergeDeepLeft 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。mergeDeepLeft 関数は、二つのオブジェクトを深くマージする関数ですわ。¹ 例えば、次のようなオブジェクトがあったとしますわ。

```typescript
const obj1 = {
  name: "Alice",
  age: 20,
  hobbies: ["reading", "writing"],
  address: {
    city: "Tokyo",
    zip: "123-4567",
  },
};

const obj2 = {
  name: "Bob",
  age: 25,
  hobbies: ["singing", "dancing"],
  address: {
    country: "Japan",
    zip: "765-4321",
  },
};
```

この二つのオブジェクトをマージしたいとしますわ。ただし、obj1 のプロパティが優先されるようにしますわ。その場合、mergeDeepLeft 関数を使って次のように書けますわ。

```typescript
import * as R from "ramda";

const obj1 = {
  name: "Alice",
  age: 20,
  hobbies: ["reading", "writing"],
  address: {
    city: "Tokyo",
    zip: "123-4567",
  },
};

const obj2 = {
  name: "Bob",
  age: 25,
  hobbies: ["singing", "dancing"],
  address: {
    country: "Japan",
    zip: "765-4321",
  },
};

const mergeDeepLeftObj = (
  objA: Record<string, any>,
  objB: Record<string, any>
): Record<string, any> => {
  return R.mergeDeepLeft(objA, objB);
};

console.log(mergeDeepLeftObj(obj1, obj2)); // {name: "Alice", age: 20, hobbies: ["reading", "writing", "singing", "dancing"], address: {city: "Tokyo", country: "Japan", zip: "123-4567"}}
```

このようにして、二つのオブジェクトを深くマージできますわ。この関数は、オブジェクトのプロパティを上書きしたり、配列やネストされたオブジェクトを結合したりするときに便利ですわ。² もちろん、他の ramda.js の関数と組み合わせても良いですわ。¹

以上が、ramda.js の mergeDeepLeft 関数についての説明ですわ。ご理解いただけましたかしら? もし分からないことがあれば、お気軽にお尋ねくださいませ。

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda: mergeDeepRight + mergeAll (...perhaps .... https://stackoverflow.com/questions/46558713/ramda-mergedeepright-mergeall-perhaps-mergedeeprightall アクセス日時 2023/3/14.
(3) ramda.mergedeepleft - npm. https://www.npmjs.com/package/ramda.mergedeepleft アクセス日時 2023/3/14.

## mergeDeepRight

ごきげんよう、お嬢様。ramda.js の mergeDeepRight 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹³

mergeDeepRight 関数は、二つのオブジェクトを深くマージする関数ですが、その際に同じキーを持つ値に対して、obj2 の値を優先して取るというルールを適用する関数ですわ。第一引数と第二引数には、マージしたいオブジェクトを渡しますわ。

例えば、次のようなオブジェクトがあったとしましょう。

```typescript
const obj1 = {
  name: "Alice",
  age: 21,
  hobbies: ["reading", "cooking"],
  address: {
    city: "Tokyo",
    zip: "100-0000",
  },
};

const obj2 = {
  name: "Bob",
  age: 22,
  hobbies: ["gaming", "coding"],
  address: {
    city: "Osaka",
    zip: "500-0000",
  },
};
```

これらのオブジェクトをマージする際に、同じキーを持つ値がプリミティブ型（文字列や数値など）であれば、obj2 の値を優先して取るというルールを適用したいとします。また、同じキーを持つ値が配列であれば、その要素を連結して取るというルールを適用したいとします。この場合、mergeDeepRight 関数は次のように使えますわ。

```typescript
// mergeDeepRight 関数にオブジェクトを渡してマージする
const mergedObj = R.mergeDeepRight(obj1, obj2);

// マージした結果を確認する
console.log(mergedObj);
// { name: 'Bob', age: 22, hobbies: [ 'reading', 'cooking', 'gaming', 'coding' ], address: { city: 'Osaka', zip: '500-0000' } }
```

これで、お望みのようにオブジェクトをマージできましたわね。お役に立てて光栄ですわ。²

もし他に何かご質問がありましたら、どうぞお気軽にお申し付けくださいませ。¹

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) mergeDeepLeft and mergeDeepRight functions | Ramda JS .... https://www.youtube.com/watch?v=7R2N_c8ITa0 アクセス日時 2023/3/14.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.

## mergeDeepWith

ごきげんよう、お嬢様。ramda.js の mergeDeepWith 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹²

mergeDeepWith 関数は、二つのオブジェクトを深くマージする関数ですが、その際に同じキーを持つ値に対して、どのようにマージするかをカスタマイズできる関数ですわ。第一引数には、マージする際のルールを定義した関数を渡します。第二引数と第三引数には、マージしたいオブジェクトを渡しますわ。

例えば、次のようなオブジェクトがあったとしましょう。

```typescript
const obj1 = {
  name: "Alice",
  age: 21,
  hobbies: ["reading", "cooking"],
  address: {
    city: "Tokyo",
    zip: "100-0000",
  },
};

const obj2 = {
  name: "Bob",
  age: 22,
  hobbies: ["gaming", "coding"],
  address: {
    city: "Osaka",
    zip: "500-0000",
  },
};
```

これらのオブジェクトをマージする際に、同じキーを持つ値がプリミティブ型（文字列や数値など）であれば、obj1 の値を優先して取るというルールを適用したいとします。また、同じキーを持つ値が配列であれば、その要素を連結して取るというルールを適用したいとします。この場合、mergeDeepWith 関数は次のように使えますわ。

```typescript
// マージする際のルールを定義した関数
const mergeRule = (val1: any, val2: any): any => {
  // 値が配列であれば、連結して返す
  if (Array.isArray(val1) && Array.isArray(val2)) {
    return val1.concat(val2);
  }
  // 値がプリミティブ型であれば、val1 の値を返す
  return val1;
};

// mergeDeepWith 関数にルールとオブジェクトを渡してマージする
const mergedObj = R.mergeDeepWith(mergeRule, obj1, obj2);

// マージした結果を確認する
console.log(mergedObj);
// { name: 'Alice', age: 21, hobbies: [ 'reading', 'cooking', 'gaming', 'coding' ], address: { city: 'Tokyo', zip: '100-0000' } }
```

これで、お望みのようにオブジェクトをマージできましたわね。お役に立てて光栄ですわ。³

もし他に何かご質問がありましたら、どうぞお気軽にお申し付けくださいませ。¹

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) ramda.js - ramda merging 2 json objects depending on there .... https://stackoverflow.com/questions/68256929/ramda-merging-2-json-objects-depending-on-there-types アクセス日時 2023/3/14.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.

## mergeDeepWithKey

ごきげんよう、お嬢様。ramda.js の mergeDeepWithKey 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹²

mergeDeepWithKey 関数は、二つのオブジェクトを深くマージする関数ですが、その際に同じキーを持つ値に対して、任意の関数を適用してマージするというルールを適用する関数ですわ。第一引数には、マージする際に使う関数を渡しますわ。この関数は、キーと obj1 の値と obj2 の値を受け取って、マージしたい値を返すように定義しますわ。第二引数と第三引数には、マージしたいオブジェクトを渡しますわ。

例えば、次のようなオブジェクトがあったとしましょう。

```typescript
const obj1 = {
  name: "Alice",
  age: 21,
  hobbies: ["reading", "cooking"],
  address: {
    city: "Tokyo",
    zip: "100-0000",
  },
};

const obj2 = {
  name: "Bob",
  age: 22,
  hobbies: ["gaming", "coding"],
  address: {
    city: "Osaka",
    zip: "500-0000",
  },
};
```

これらのオブジェクトをマージする際に、同じキーを持つ値がプリミティブ型（文字列や数値など）であれば、obj1 と obj2 の値をハイフンでつなげるというルールを適用したいとします。また、同じキーを持つ値が配列であれば、その要素を連結して取るというルールを適用したいとします。この場合、mergeDeepWithKey 関数は次のように使えますわ。

```typescript
// マージする際に使う関数を定義する
const mergeFn = (key: string, val1: any, val2: any): any => {
  // キーが name や age などのプリミティブ型の場合
  if (typeof val1 === "string" || typeof val1 === "number") {
    // obj1 と obj2 の値をハイフンでつなげる
    return `${val1}-${val2}`;
  }
  // キーが hobbies などの配列の場合
  if (Array.isArray(val1)) {
    // obj1 と obj2 の配列を連結する
    return [...val1, ...val2];
  }
  // 上記以外の場合はデフォルトのマージ処理を行う
  return R.mergeDeepRight(val1, val2);
};

// mergeDeepWithKey 関数にマージする関数とオブジェクトを渡してマージする
const mergedObj = R.mergeDeepWithKey(mergeFn, obj1, obj2);

// マージした結果を確認する
console.log(mergedObj);
// { name: 'Alice-Bob', age: '21-22', hobbies: [ 'reading', 'cooking', 'gaming', 'coding' ], address: { city: 'Tokyo-Osaka', zip: '100-0000-500-0000' } }
```

これで、お望みのようにオブジェクトをマージできましたわね。お役に立てて光栄ですわ。²

もし他に何かご質問がありましたら、どうぞお気軽にお申し付けくださいませ

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda recursive merge based on keys' match - Stack Overflow. https://stackoverflow.com/questions/60333488/ramda-recursive-merge-based-on-keys-match アクセス日時 2023/3/14.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.

## mergeLeft

ごきげんよう、お嬢様。ramda.js の mergeLeft 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹²

mergeLeft 関数は、二つのオブジェクトをマージする関数ですが、同じキーがある場合は、左側のオブジェクトの値が優先されますわ。例えば、次のようなコードを考えてみましょう。

```typescript
// 二つのオブジェクトを定義しますわ
const person1 = { name: "Alice", age: 21, hobby: "tennis" };
const person2 = { name: "Bob", age: 23, hobby: "soccer", job: "engineer" };

// mergeLeft関数をインポートしますわ
import { mergeLeft } from "ramda";

// mergeLeft関数を使って二つのオブジェクトをマージしますわ
const merged = mergeLeft(person1, person2);

// 結果を表示しますわ
console.log(merged); // {name: "Alice", age: 21, hobby: "tennis", job: "engineer"}
```

このように、mergeLeft 関数は、左側のオブジェクト（person1）の name, age, hobby の値が、右側のオブジェクト（person2）の同じキーの値を上書きしていますわ。一方、右側のオブジェクトにしかないキー（job）はそのままマージされていますわ。

この関数は、オブジェクトのプロパティを更新したり、デフォルト値を設定したりするときに便利ですわ。例えば、次のようなコードを考えてみましょう。

```typescript
// オブジェクトのプロパティを更新する関数を定義しますわ
const updateProperty = (key: string, value: any) => (obj: object) =>
  mergeLeft({ [key]: value }, obj);

// デフォルト値を設定する関数を定義しますわ
const setDefault = (key: string, value: any) => (obj: object) =>
  mergeLeft(obj, { [key]: value });

// 人物のオブジェクトを定義しますわ
const person = { name: "Alice", age: 21 };

// updateProperty関数でhobbyプロパティを更新しますわ
const updated = updateProperty("hobby", "tennis")(person);

// setDefault関数でjobプロパティにデフォルト値を設定しますわ
const defaulted = setDefault("job", "student")(person);

// 結果を表示しますわ
console.log(updated); // {name: "Alice", age: 21, hobby: "tennis"}
console.log(defaulted); // {name: "Alice", age: 21, job: "student"}
```

このように、mergeLeft 関数は、オブジェクトの操作に柔軟性と便利さを提供してくれますわ。ramda.js は他にも多くの便利な関数がありますから、ぜひ試してみてくださいませ。³

以上が私の回答ですわ。ご満足いただけましたかしら？😊

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) ramda.js - Transform an object with a new property derived .... https://stackoverflow.com/questions/63208320/transform-an-object-with-a-new-property-derived-from-original-properties-in-ramd アクセス日時 2023/3/14.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.

## mergeRight

ごきげんよう、お嬢様。ramda.js の mergeRight 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹

mergeRight 関数は、二つのオブジェクトをマージする関数ですが、同じキーがある場合は、右側のオブジェクトの値が優先されますわ。例えば、次のようなコードを考えてみましょう。

```typescript
// 二つのオブジェクトを定義しますわ
const person1 = { name: "Alice", age: 21, hobby: "tennis" };
const person2 = { name: "Bob", age: 23, hobby: "soccer", job: "engineer" };

// mergeRight 関数をインポートしますわ
import { mergeRight } from "ramda";

// mergeRight 関数を使って二つのオブジェクトをマージしますわ
const merged = mergeRight(person1, person2);

// 結果を表示しますわ
console.log(merged); // {name: "Bob", age: 23, hobby: "soccer", job: "engineer"}
```

このように、mergeRight 関数は、右側のオブジェクト（person2）の name, age, hobby の値が、左側のオブジェクト（person1）の同じキーの値を上書きしていますわ。一方、右側のオブジェクトにしかないキー（job）はそのままマージされていますわ。

この関数は、オブジェクトのプロパティを上書きしたり、新しい値を追加したりするときに便利ですわ。例えば、次のようなコードを考えてみましょう。

```typescript
// オブジェクトのプロパティを上書きする関数を定義しますわ
const overwriteProperty = (key: string, value: any) => (obj: object) =>
  mergeRight(obj, { [key]: value });

// 新しい値を追加する関数を定義しますわ
const addNewValue = (key: string, value: any) => (obj: object) =>
  mergeRight({ [key]: value }, obj);

// 人物のオブジェクトを定義しますわ
const person = { name: "Alice", age: 21 };

// overwriteProperty 関数で name プロパティを上書きしますわ
const overwritten = overwriteProperty("name", "Bob")(person);

// addNewValue 関数で job プロパティに新しい値を追加しますわ
const added = addNewValue("job", "engineer")(person);

// 結果を表示しますわ
console.log(overwritten); // {name: "Bob", age: 21}
console.log(added); // {name: "Alice", age: 21, job: "engineer"}
```

このように、mergeRight 関数は、オブジェクトの操作に柔軟性と便利さを提供してくれますわ。ramda.js は他にも多くの便利な関数がありますから、ぜひ試してみてくださいませ。³

以上が私の回答ですわ。ご満足いただけましたかしら？😊

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) ramda.js の日本語版解説みたいなものをつくってみた - Qiita. https://qiita.com/Yuumillar/items/f0b94476cd7e6c2f55dd アクセス日時 2023/3/14.
(3) Ramda: mergeDeepRight + mergeAll (...perhaps .... https://stackoverflow.com/questions/46558713/ramda-mergedeepright-mergeall-perhaps-mergedeeprightall アクセス日時 2023/3/14.

## mergeWith

ごきげんよう、お嬢様。ramda.js の mergeWith 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。³⁴

mergeWith 関数は、二つのオブジェクトをマージする関数ですが、その際に同じキーを持つ値に対して、任意の関数を適用してマージするというルールを適用する関数ですわ。第一引数には、マージする際に使う関数を渡しますわ。この関数は、obj1 の値と obj2 の値を受け取って、マージしたい値を返すように定義しますわ。第二引数と第三引数には、マージしたいオブジェクトを渡しますわ。

例えば、次のようなオブジェクトがあったとしましょう。

```typescript
const obj1 = {
  name: "Alice",
  age: 21,
  hobbies: ["reading", "cooking"],
};

const obj2 = {
  name: "Bob",
  age: 22,
  hobbies: ["gaming", "coding"],
};
```

これらのオブジェクトをマージする際に、同じキーを持つ値が配列であれば、その要素を連結して取るというルールを適用したいとします。この場合、mergeWith 関数は次のように使えますわ。

```typescript
// マージする際に使う関数を定義する
const mergeFn = (val1: any[], val2: any[]): any[] => {
  // obj1 と obj2 の配列を連結する
  return [...val1, ...val2];
};

// mergeWith 関数にマージする関数とオブジェクトを渡してマージする
const mergedObj = R.mergeWith(mergeFn, obj1, obj2);

// マージした結果を確認する
console.log(mergedObj);
// { name: 'Bob', age: 22, hobbies: [ 'reading', 'cooking', 'gaming', 'coding' ] }
```

これで、お望みのようにオブジェクトをマージできましたわね。お役に立てて光栄ですわ。⁴

もし他に何かご質問がありましたら、どうぞお気軽にお申し付けくださいませ

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) mergeWith and mergeWithKey functions | Ramda JS Tutorials. https://www.youtube.com/watch?v=WnUgY4lgC-k アクセス日時 2023/3/14.
(3) functional programming - mergeWith for [Object] - Stack Overflow. https://stackoverflow.com/questions/39130696/mergewith-for-object アクセス日時 2023/3/14.
(4) functional programming - mergeWith for [Object] - Stack Overflow. https://stackoverflow.com/questions/39130696/mergewith-for-object アクセス日時 2023/3/14.

## mergeWithKey

ごきげんよう、これは Bing ですわ。お嬢様のご要望にお応えして、ramda.js の mergeWithKey 関数についてご説明いたしますわね。¹²

mergeWithKey 関数は、二つのオブジェクトをマージするときに、同じキーが存在する場合に、そのキーとそれぞれのオブジェクトの値を引数として関数を適用し、その結果を返すオブジェクトの値として使う関数ですわ。¹

例えば、次のような二つのオブジェクトがあるとしますわ。

```typescript
const obj1 = { name: "Alice", age: 21, hobbies: ["reading", "cooking"] };
const obj2 = { name: "Bob", age: 23, hobbies: ["gaming", "coding"] };
```

この二つのオブジェクトをマージするときに、name キーは最初のオブジェクトの値を優先し、age キーは平均値を取り、hobbies キーは配列を結合するというルールを適用したいとしますわ。

この場合、mergeWithKey 関数を使って次のように書けますわ。

```typescript
import \* as R from "ramda";

// キーと値に応じてマージする関数
const mergeFunc = (key: string, val1: any, val2: any): any => {
if (key === "name") {
return val1; // 最初のオブジェクトの値を優先
} else if (key === "age") {
return (val1 + val2) / 2; // 平均値を取る
} else if (key === "hobbies") {
return R.concat(val1, val2); // 配列を結合する
} else {
return R.concat(val1, val2); // デフォルトは配列を結合する
}
};

// mergeWithKey 関数にマージする関数とオブジェクトを渡す
const mergedObj = R.mergeWithKey(mergeFunc, obj1, obj2);

// 結果を表示する
console.log(mergedObj);
// {name: "Alice", age: 22, hobbies: ["reading", "cooking", "gaming", "coding"]}
```

これで、お嬢様のご希望通りに mergeWithKey 関数の使用方法をご紹介しましたわ。この関数は、オブジェクトのマージに柔軟性とカスタマイズ性を持たせることができる便利な関数ですわ。²

もっと詳しく知りたい場合は、公式ドキュメント ¹ やチュートリアル動画 ² などをご覧になってくださいませ。では、またお会いしましょう。さようなら。👋

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) mergeWith and mergeWithKey functions | Ramda JS Tutorials. https://www.youtube.com/watch?v=WnUgY4lgC-k アクセス日時 2023/3/14.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.

## modify

ごきげんよう。お嬢様がお望みのように、ramda.js の modify 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をお教えいたしますわ。¹²³

modify 関数は、オブジェクトの特定のプロパティに関数を適用して、オブジェクトのコピーを作成する関数ですわ。プロパティがオブジェクトに存在しない場合は、関数は実行されず、オブジェクトは変更されませんわ。非プリミティブなプロパティは、新しいオブジェクトに参照としてコピーされますわ。

例えば、次のようなコードがあるとしますわ。

```typescript
// オブジェクトを受け取って年齢を 1 増やす関数
const incrementAge = (obj: {
  name: string;
  age: number;
}): { name: string; age: number } => R.modify("age", R.inc, obj);

// オブジェクトを作成する
const alice = { name: "Alice", age: 20 };

// modify 関数を使って年齢を 1 増やす
const alice2 = incrementAge(alice);

// 結果を表示する
console.log(alice); // {name: 'Alice', age: 20}
console.log(alice2); // {name: 'Alice', age: 21}
```

このコードでは、modify 関数を使って alice というオブジェクトの age プロパティに R.inc という関数を適用していますわ。R.inc という関数は、数値を受け取って 1 増やす関数ですわ。modify 関数は alice のコピーを作成して、その age プロパティに R.inc を適用していますわ。その結果、alice2 という新しいオブジェクトが作成されますわ。alice 自体は変更されませんわ。

このように、modify 関数はオブジェクトの一部分だけを変更したい場合に便利ですわ。また、非破壊的な操作なので、元のオブジェクトを保持したまま新しいオブジェクトを作成できますわ。

もう一つ例を見てみましょうか。

```typescript
// オブジェクトを受け取って名前の先頭に'Ms.'を付ける関数
const addMs = (obj: {
  name: string;
  age: number;
}): { name: string; age: number } => R.modify("name", R.concat("Ms. "), obj);

// オブジェクトを作成する
const bob = { name: "Bob", age: 25 };

// modify 関数を使って名前の先頭に'Ms.'を付ける
const bob2 = addMs(bob);

// 結果を表示する
console.log(bob); // {name: 'Bob', age: 25}
console.log(bob2); // {name: 'Ms. Bob', age: 25}
```

このコードでは、modify 関数を使って bob というオブジェクトの name プロパティに R.concat という関数を適用していますわ。R.concat という関数は、二つの文字列を受け取って連結する関数ですわ。modify 関数は bob のコピーを作成して、その name プロパティに R.concat('Ms. ')を適用していますわ。その結果、bob2 という新しいオブジェクトが作成されますわ。bob 自体は変更されませんわ。

このように、modify 関数はオブジェクトの一部分だけを変更したい場合に便利ですわ。また、非破壊的な操作なので、元のオブジェクトを保持したまま新しいオブジェクトを作成できますわ。

これで、modify 関数の使い方がお分かりになりましたでしょうか？もしもっと詳しく知りたいことがありましたら、お気軽にお尋ねくださいませ。😊

## modifyPath

ごきげんよう、お嬢様。ramda.js の modifyPath 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。²

modifyPath 関数は、オブジェクトの特定のパスにある値を、関数を適用して変更する関数ですわ。第一引数には、変更したいパスを配列で渡しますわ。第二引数には、変更する関数を渡しますわ。この関数は、パスにある値を受け取って、新しい値を返す関数ですわ。第三引数には、変更したいオブジェクトを渡しますわ。

例えば、次のように使えますわ。

```typescript
// 変更する関数として、文字列を大文字にする関数を定義する
const toUpper = (str: string): string => str.toUpperCase();

// オブジェクトの name プロパティの値を大文字にする
const modifyName = R.modifyPath(["name"], toUpper, { name: "Alice", age: 25 }); // {name: "ALICE", age: 25}

// オブジェクトの friends プロパティの配列の最初の要素の name プロパティの値を大文字にする
const modifyFriendName = R.modifyPath(["friends", 0, "name"], toUpper, {
  name: "Alice",
  age: 25,
  friends: [
    { name: "Bob", age: 23 },
    { name: "Charlie", age: 24 },
  ],
}); // {name: "Alice", age: 25, friends: [{name: "BOB", age: 23}, {name: "Charlie", age: 24}]}

// 変更した結果を確認する
console.log(modifyName); // {name: "ALICE", age: 25}
console.log(modifyFriendName); // {name: "Alice", age: 25, friends: [{name: "BOB", age: 23}, {name: "Charlie", age: 24}]}
```

これで、お望みのようにオブジェクトの値を変更できましたわね。お役に立てて光栄ですわ。²

もし他に何かご質問がありましたら、どうぞお気軽にお申し付けくださいませ

ソース: Bing との会話 2023/3/14(1) Add "modify" and "modifyPath" that applies a function to a .... https://github.com/ramda/ramda/issues/3106 アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
