---
title: "Object"
---

Object では Object に関する関数を紹介。現在 9 個。

import { Callout } from "nextra-theme-docs";

## assoc

オブジェクトに key, value を追加する関数です。  
カリー化されているので後回しにできるのが便利です。  
あと再代入をしないので、もとのオブジェクトに影響しないのもいいね！

```ts
import { assoc } from "ramda";

const user = { id: 1 };
const user2 = { id: 2 };
const user3 = { id: 3 };

/* カリー化した場合 */
const addNameUser = assoc("name", "TANAKA")(user);
console.log(addNameUser); // { id: 1, name: 'TANAKA' }

/* 3つ引数を渡す場合 */
const addNameUser2 = assoc("name", "YAMADA", user2);
console.log(addNameUser2); // { id: 2, name: 'YAMADA' }

/* ramdaを使わないならこんな感じ */
const addNameuser3 = { ...user3, name: "HIRAYAMA" };
console.log(addNameuser3); // { id: 3, name: 'HIRAYAMA' }
```

<Callout type="warning" emoji="⚠️" style={{"white-space": "pre-wrap;"}}>
<div >
注意：型は補完されない  
本来、USER 型は address などというプロパティはないが、assoc なら追加できてしまう。  
プロパティを追加するのは assoc で良いが、変更するならスプレッド構文でコピーするか、immer などを使うと良い。
</div>
</Callout>
```ts
type User = {
  id: number;
  name: string;
};
const user4 = { id: 4, name: "ISHIDA" };
const newUser: User = assoc("address", "京都府京都市駅前1丁目1-1-1", user4);
console.log({ newUser }); // { newUser: { id: 4, name: 'ISHIDA', address: '京都府京都市駅前1丁目1-1-1' } }
```

## prop

引数 1 にオブジェクトのキー、引数 2 にオブジェクトを渡す。  
そうするとそのキーのバリューが取ってこられる関数です。  
ramda だといろいろな関数で prop を使います。

```ts
R.prop("x", { x: 100 }); //=> 100
R.prop("x", {}); //=> undefined
R.prop(0, [100]); //=> 100
R.compose(R.inc, R.prop("x"))({ x: 3 }); //=> 4
```

## clone

オブジェクトをディープコピーしてくれる関数です。  
下記例、shallowCopy 関数はスプレッド構文を使用してシャローコピーをしています。  
コピーした obj2 のプロパティにある posts のなかにある post の title を変えました。  
そうすると、コピー元の obj のほうも posts の index0 にある post の title が変わってしまいます。

deepCopy 関数では ramda.js の clone 関数を使用しました。  
そうすると、同じように obj2 のプロパティを変更しても obj のほうには影響がありません。

このようにネストしたオブジェクトを安全にコピーできます。  
ただ、ディープコピーは重い処理です。本当に必要なとき以外はシャローコピーで十分かもしれません。

```ts
import { clone } from "ramda";

const shallowCopy = () => {
  const post = { id: 1, title: "ご挨拶" };
  const obj = { id: 1, name: "TANAKA", posts: [post] };
  const obj2 = { ...obj };
  if (obj2.posts[0] === undefined) return;
  obj2.posts[0].title = "ご挨拶(修正版)";
  console.log(obj2); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶(修正版)' } ] }
  console.log(obj); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶(修正版)' } ] } ←変わってしまった！
};
shallowCopy();

const deepCopy = () => {
  const post = { id: 1, title: "ご挨拶" };
  const obj = { id: 1, name: "TANAKA", posts: [post] };
  const obj2 = clone(obj);
  if (obj2.posts[0] === undefined) return;
  obj2.posts[0].title = "ご挨拶(修正版)";
  console.log(obj2); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶(修正版)' } ] }
  console.log(obj); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶' } ] } ←変わってない！
};
deepCopy();
```

## dissoc

これは assoc がわかれば簡単なので、公式の例を拝借。  
asssoc の逆。  
第一引数に Object の key を取り、その key:value を Object から削除する。

```ts
dissoc("b", { a: 1, b: 2, c: 3 }); //=> {a: 1, c: 3}
```

## dissocPath

これは assocPath がわかれば簡単  
shallowCopy らしい

```ts
/* aのなかのbのなかのcを消す */
R.dissocPath(["a", "b", "c"], { a: { b: { c: 42 } } }); //=> {a: {b: {}}}
```

## values

Object の value だけを取ってくる関数。

```ts
values({ a: 1, b: 2, c: 3 }); //=> [1, 2, 3]
```

## keys

Object の key だけを取ってくる関数。

```ts
keys({ a: 1, b: 2, c: 3 }); //=> ['a', 'b', 'c']
```

## toPairs

Object の key と value を配列に入れてくれる関数。  
Object を配列的に処理したいときに使うかな……。
key と value をタプルにしてくれる、みたいな感じ。

```ts
toPairs({ a: 1, b: 2, c: 3 }); //=> [['a', 1], ['b', 2], ['c', 3]]
```

## assocPath

assoc の path(key の nest)を配列でできる。  
引数 1 がオブジェクトのパスの string[]  
引数 2 が値
引数 3 がもとのオブジェクト

```ts
/* aのなかのbのなかのcに42という値を与えたい */
R.assocPath(["a", "b", "c"], 42, { a: { b: { c: 0 } } }); //=> {a: {b: {c: 42}}}

// Any missing or non-object keys in path will be overridden
/* bとかcがないときは追加される */
R.assocPath(["a", "b", "c"], 42, { a: 5 }); //=> {a: {b: {c: 42}}}
```

## toPairsIn

```
typescript
const obj = {
a: 1,
b: 2,
c: 3
};

// obj のプロトタイプに d というプロパティを追加する
Object.prototype.d = 4;

// toPairsIn 関数の型は、
// (obj: object) => [string, any][]
// となります。
// obj はオブジェクト型、返り値は文字列と任意の型のペアの配列型です。

// toPairsIn 関数を obj に適用すると、
// [[a, 1], [b, 2], [c, 3], [d, 4]]
// という配列が返ります。
// 継承された d プロパティも含まれています。
const result = R.toPairsIn(obj);

// 結果をコンソールに出力する
console.log("obj のすべてのプロパティを[key, value]のペアに変換した結果は、");
console.log(result);
```

このように、toPairsIn 関数はオブジェクトのプロパティをペアに変換する関数です。もっと知りたいことがありますか？

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(3) toPairs and toPairsIn functions | Ramda JS Tutorials - YouTube. https://www.youtube.com/watch?v=USwrZkubf0M アクセス日時 2023/3/12.

## eqProps

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の eqProps 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

eqProps 関数は、二つのオブジェクトに対して、指定したプロパティの値が等しいかどうかを判定する関数ですわ。¹

例えば、以下のようなオブジェクトがあるとしましょう。

```js
const alice = { name: "Alice", age: 20, hair: "blonde" }; // Alice という名前で 20 歳でブロンドの髪のオブジェクト
const bob = { name: "Bob", age: 20, hair: "brown" }; // Bob という名前で 20 歳でブラウンの髪のオブジェクト
const charlie = { name: "Charlie", age: 25, hair: "blonde" }; // Charlie という名前で 25 歳でブロンドの髪のオブジェクト
```

このオブジェクトを eqProps 関数に渡すと、以下のようになりますわ。

```js
const eqByAge = R.eqProps("age"); // age プロパティの値が等しいかどうかを判定する関数を作る
const aliceAndBob = eqByAge(alice, bob); // alice と bob の age プロパティの値が等しいかどうかを判定する
const aliceAndCharlie = eqByAge(alice, charlie); // alice と charlie の age プロパティの値が等しいかどうかを判定する
console.log("Alice と Bob は同じ年齢ですか？" + aliceAndBob + "ですわ"); // Alice と Bob は同じ年齢ですか？true ですわ
console.log("Alice と Charlie は同じ年齢ですか？" + aliceAndCharlie + "ですわ"); // Alice と Charlie は同じ年齢ですか？false ですわ
```

このように、eqProps 関数を使うと、二つのオブジェクトに対して、任意のプロパティの値が等しいかどうかを簡単に判定できますわ。これは、オブジェクトの特定のプロパティを比較したいときに便利ですわ。³

以上が、ramda.js の eqProps 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/0.9/docs/ アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.

## evolve

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の evolve 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

evolve 関数は、オブジェクトのプロパティに対して、変換関数を適用して新しいオブジェクトを作る関数ですわ。²

例えば、以下のようなオブジェクトがあるとしましょう。

```js
const person = {
  name: "Alice",
  age: 20,
  hobbies: ["reading", "writing", "singing"],
}; // Alice という名前で 20 歳で趣味が読書と執筆と歌唱のオブジェクト
```

このオブジェクトを evolve 関数に渡すと、以下のようになりますわ。

```js
const transform = {
  // 変換関数を定義するオブジェクト
  name: R.toUpper, // name プロパティには大文字にする関数を適用する
  age: R.add(1), // age プロパティには 1 を足す関数を適用する
  hobbies: R.append("dancing"), // hobbies プロパティにはダンスを追加する関数を適用する
};
const newPerson = R.evolve(transform, person); // evolve 関数に変換関数と元のオブジェクトを渡す
console.log("変換前のオブジェクトは" + JSON.stringify(person) + "ですわ"); // 変換前のオブジェクトは{"name":"Alice","age":20,"hobbies":["reading","writing","singing"]}ですわ
console.log("変換後のオブジェクトは" + JSON.stringify(newPerson) + "ですわ"); // 変換後のオブジェクトは{"name":"ALICE","age":21,"hobbies":["reading","writing","singing","dancing"]}ですわ
```

このように、evolve 関数を使うと、オブジェクトのプロパティに対して、任意の変換関数を適用して新しいオブジェクトを作ることができますわ。これは、オブジェクトの特定のプロパティを変更したいときに便利ですわ。²

以上が、ramda.js の evolve 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) javascript - ramda evolve function example - Stack Overflow. https://stackoverflow.com/questions/42135771/ramda-evolve-function-example アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
