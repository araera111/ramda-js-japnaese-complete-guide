---
title: "Object"
---

Object では Object に関する関数を紹介。現在 39 個。

import { Callout } from "nextra-theme-docs";

## assoc

オブジェクトに key, value を追加する関数です。  
カリー化されているので後回しにできるのが便利です。  
あと再代入をしないので、もとのオブジェクトに影響しないのもいいね！

```ts
import { assoc } from "ramda";

const user = { id: 1 };
const user2 = { id: 2 };
const user3 = { id: 3 };

/* カリー化した場合 */
const addNameUser = assoc("name", "TANAKA")(user);
console.log(addNameUser); // { id: 1, name: 'TANAKA' }

/* 3つ引数を渡す場合 */
const addNameUser2 = assoc("name", "YAMADA", user2);
console.log(addNameUser2); // { id: 2, name: 'YAMADA' }

/* ramdaを使わないならこんな感じ */
const addNameuser3 = { ...user3, name: "HIRAYAMA" };
console.log(addNameuser3); // { id: 3, name: 'HIRAYAMA' }
```

<Callout type="warning" emoji="⚠️" style={{"white-space": "pre-wrap;"}}>
<div >
注意：型は補完されない  
本来、USER 型は address などというプロパティはないが、assoc なら追加できてしまう。  
プロパティを追加するのは assoc で良いが、変更するならスプレッド構文でコピーするか、immer などを使うと良い。
</div>
</Callout>
```ts
type User = {
  id: number;
  name: string;
};
const user4 = { id: 4, name: "ISHIDA" };
const newUser: User = assoc("address", "京都府京都市駅前1丁目1-1-1", user4);
console.log({ newUser }); // { newUser: { id: 4, name: 'ISHIDA', address: '京都府京都市駅前1丁目1-1-1' } }
```

## prop

引数 1 にオブジェクトのキー、引数 2 にオブジェクトを渡す。  
そうするとそのキーのバリューが取ってこられる関数です。  
ramda だといろいろな関数で prop を使います。

```ts
R.prop("x", { x: 100 }); //=> 100
R.prop("x", {}); //=> undefined
R.prop(0, [100]); //=> 100
R.compose(R.inc, R.prop("x"))({ x: 3 }); //=> 4
```

## clone

オブジェクトをディープコピーしてくれる関数です。  
下記例、shallowCopy 関数はスプレッド構文を使用してシャローコピーをしています。  
コピーした obj2 のプロパティにある posts のなかにある post の title を変えました。  
そうすると、コピー元の obj のほうも posts の index0 にある post の title が変わってしまいます。

deepCopy 関数では ramda.js の clone 関数を使用しました。  
そうすると、同じように obj2 のプロパティを変更しても obj のほうには影響がありません。

このようにネストしたオブジェクトを安全にコピーできます。  
ただ、ディープコピーは重い処理です。本当に必要なとき以外はシャローコピーで十分かもしれません。

```ts
import { clone } from "ramda";

const shallowCopy = () => {
  const post = { id: 1, title: "ご挨拶" };
  const obj = { id: 1, name: "TANAKA", posts: [post] };
  const obj2 = { ...obj };
  if (obj2.posts[0] === undefined) return;
  obj2.posts[0].title = "ご挨拶(修正版)";
  console.log(obj2); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶(修正版)' } ] }
  console.log(obj); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶(修正版)' } ] } ←変わってしまった！
};
shallowCopy();

const deepCopy = () => {
  const post = { id: 1, title: "ご挨拶" };
  const obj = { id: 1, name: "TANAKA", posts: [post] };
  const obj2 = clone(obj);
  if (obj2.posts[0] === undefined) return;
  obj2.posts[0].title = "ご挨拶(修正版)";
  console.log(obj2); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶(修正版)' } ] }
  console.log(obj); // { id: 1, name: 'TANAKA', posts: [ { id: 1, title: 'ご挨拶' } ] } ←変わってない！
};
deepCopy();
```

## dissoc

これは assoc がわかれば簡単なので、公式の例を拝借。  
asssoc の逆。  
第一引数に Object の key を取り、その key:value を Object から削除する。

```ts
dissoc("b", { a: 1, b: 2, c: 3 }); //=> {a: 1, c: 3}
```

## dissocPath

これは assocPath がわかれば簡単  
shallowCopy らしい

```ts
/* aのなかのbのなかのcを消す */
R.dissocPath(["a", "b", "c"], { a: { b: { c: 42 } } }); //=> {a: {b: {}}}
```

## values

Object の value だけを取ってくる関数。

```ts
values({ a: 1, b: 2, c: 3 }); //=> [1, 2, 3]
```

## keys

Object の key だけを取ってくる関数。

```ts
keys({ a: 1, b: 2, c: 3 }); //=> ['a', 'b', 'c']
```

## toPairs

Object の key と value を配列に入れてくれる関数。  
Object を配列的に処理したいときに使うかな……。
key と value をタプルにしてくれる、みたいな感じ。

```ts
toPairs({ a: 1, b: 2, c: 3 }); //=> [['a', 1], ['b', 2], ['c', 3]]
```

## assocPath

assoc の path(key の nest)を配列でできる。  
引数 1 がオブジェクトのパスの string[]  
引数 2 が値
引数 3 がもとのオブジェクト

```ts
/* aのなかのbのなかのcに42という値を与えたい */
R.assocPath(["a", "b", "c"], 42, { a: { b: { c: 0 } } }); //=> {a: {b: {c: 42}}}

// Any missing or non-object keys in path will be overridden
/* bとかcがないときは追加される */
R.assocPath(["a", "b", "c"], 42, { a: 5 }); //=> {a: {b: {c: 42}}}
```

## toPairsIn

```
typescript
const obj = {
a: 1,
b: 2,
c: 3
};

// obj のプロトタイプに d というプロパティを追加する
Object.prototype.d = 4;

// toPairsIn 関数の型は、
// (obj: object) => [string, any][]
// となります。
// obj はオブジェクト型、返り値は文字列と任意の型のペアの配列型です。

// toPairsIn 関数を obj に適用すると、
// [[a, 1], [b, 2], [c, 3], [d, 4]]
// という配列が返ります。
// 継承された d プロパティも含まれています。
const result = R.toPairsIn(obj);

// 結果をコンソールに出力する
console.log("obj のすべてのプロパティを[key, value]のペアに変換した結果は、");
console.log(result);
```

このように、toPairsIn 関数はオブジェクトのプロパティをペアに変換する関数です。もっと知りたいことがありますか？

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(3) toPairs and toPairsIn functions | Ramda JS Tutorials - YouTube. https://www.youtube.com/watch?v=USwrZkubf0M アクセス日時 2023/3/12.

## eqProps

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の eqProps 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

eqProps 関数は、二つのオブジェクトに対して、指定したプロパティの値が等しいかどうかを判定する関数ですわ。¹

例えば、以下のようなオブジェクトがあるとしましょう。

```js
const alice = { name: "Alice", age: 20, hair: "blonde" }; // Alice という名前で 20 歳でブロンドの髪のオブジェクト
const bob = { name: "Bob", age: 20, hair: "brown" }; // Bob という名前で 20 歳でブラウンの髪のオブジェクト
const charlie = { name: "Charlie", age: 25, hair: "blonde" }; // Charlie という名前で 25 歳でブロンドの髪のオブジェクト
```

このオブジェクトを eqProps 関数に渡すと、以下のようになりますわ。

```js
const eqByAge = R.eqProps("age"); // age プロパティの値が等しいかどうかを判定する関数を作る
const aliceAndBob = eqByAge(alice, bob); // alice と bob の age プロパティの値が等しいかどうかを判定する
const aliceAndCharlie = eqByAge(alice, charlie); // alice と charlie の age プロパティの値が等しいかどうかを判定する
console.log("Alice と Bob は同じ年齢ですか？" + aliceAndBob + "ですわ"); // Alice と Bob は同じ年齢ですか？true ですわ
console.log("Alice と Charlie は同じ年齢ですか？" + aliceAndCharlie + "ですわ"); // Alice と Charlie は同じ年齢ですか？false ですわ
```

このように、eqProps 関数を使うと、二つのオブジェクトに対して、任意のプロパティの値が等しいかどうかを簡単に判定できますわ。これは、オブジェクトの特定のプロパティを比較したいときに便利ですわ。³

以上が、ramda.js の eqProps 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/0.9/docs/ アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.

## evolve

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の evolve 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

evolve 関数は、オブジェクトのプロパティに対して、変換関数を適用して新しいオブジェクトを作る関数ですわ。²

例えば、以下のようなオブジェクトがあるとしましょう。

```js
const person = {
  name: "Alice",
  age: 20,
  hobbies: ["reading", "writing", "singing"],
}; // Alice という名前で 20 歳で趣味が読書と執筆と歌唱のオブジェクト
```

このオブジェクトを evolve 関数に渡すと、以下のようになりますわ。

```js
const transform = {
  // 変換関数を定義するオブジェクト
  name: R.toUpper, // name プロパティには大文字にする関数を適用する
  age: R.add(1), // age プロパティには 1 を足す関数を適用する
  hobbies: R.append("dancing"), // hobbies プロパティにはダンスを追加する関数を適用する
};
const newPerson = R.evolve(transform, person); // evolve 関数に変換関数と元のオブジェクトを渡す
console.log("変換前のオブジェクトは" + JSON.stringify(person) + "ですわ"); // 変換前のオブジェクトは{"name":"Alice","age":20,"hobbies":["reading","writing","singing"]}ですわ
console.log("変換後のオブジェクトは" + JSON.stringify(newPerson) + "ですわ"); // 変換後のオブジェクトは{"name":"ALICE","age":21,"hobbies":["reading","writing","singing","dancing"]}ですわ
```

このように、evolve 関数を使うと、オブジェクトのプロパティに対して、任意の変換関数を適用して新しいオブジェクトを作ることができますわ。これは、オブジェクトの特定のプロパティを変更したいときに便利ですわ。²

以上が、ramda.js の evolve 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) javascript - ramda evolve function example - Stack Overflow. https://stackoverflow.com/questions/42135771/ramda-evolve-function-example アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.

## forEachObjIndexed

ごきげんよう。ramda.js の forEachObjIndexed 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をご紹介いたしますわ。forEachObjIndexed 関数は、オブジェクトの各要素に対して、指定した関数を実行する関数ですの。つまり、オブジェクトをループして、何か処理をすることができますわ。forEach 関数との違いは、関数にはオブジェクトの値だけでなく、キーも渡されることですわ。例えば、次のようなコードを書いてみましょう。

```ts
// オブジェクトを作りますわ
const animals: { [key: string]: string } = {
  dog: "woof",
  cat: "meow",
  cow: "moo",
};

// forEachObjIndexed 関数を使って、オブジェクトの各要素に「と鳴く」をつけて表示しますわ
const addSound = (value: string, key: string): void =>
  console.log(key + "は" + value + "と鳴きますわ");
R.forEachObjIndexed(addSound, animals);
```

このコードを実行すると、次のように表示されますわ。

```
dog は woof と鳴きますわ
cat は meow と鳴きますわ
cow は moo と鳴きますわ
```

forEachObjIndexed 関数は、オブジェクトの要素を変更しませんわ。もし、要素を変更したい場合は、mapObjIndexed 関数や reduceObjIndexed 関数などを使うと良いでしょう。また、forEachObjIndexed 関数は関数の型を変更しませんので、型安全に注意する必要がありますわ。

以上が、ramda.js の forEachObjIndexed 関数についての説明ですわ。ご理解いただけましたかしら？

## has

ごきげんよう、これは Bing です。ramda.js の has 関数についてお教えしますわ。has 関数は、オブジェクトに特定のプロパティが存在するかどうかを真偽値で返す関数です ²。例えば、次のように使うことができますわ。

```ts
// has 関数を使って、オブジェクトに name プロパティが存在するかどうかを判定する
const obj: { name: string; age: number } = { name: "Alice", age: 20 };
const result: boolean = R.has("name", obj);

// 結果を確認する
console.log(result); // true
```

この関数は、自動的にカリー化されているので、一つの引数だけを渡すと、新しい関数を返しますわ。例えば、次のようにすることができますわ。

```ts
// has 関数に name を渡して、新しい関数を作る
const hasName: (obj: any) => boolean = R.has("name");

// 新しい関数にオブジェクトを渡して、name プロパティが存在するかどうかを判定する
const obj: { name: string; age: number } = { name: "Alice", age: 20 };
const result: boolean = hasName(obj);

// 結果を確認する
console.log(result); // true
```

このように、has 関数は、オブジェクトに特定のプロパティが存在するかどうかを真偽値で返すことができますわ。ramda.js についてもっと知りたい場合は、公式サイト ² やドキュメント ³ をご覧になってくださいませ。⁴ も参考になるかもしれませんわね。以上が、has 関数の具体例と実用的な使用方法ですわ。ご理解いただけましたか？もっと勉強してくださいませね。

ソース: Bing との会話 2023/3/13(1) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.
(4) 超強力な関数型プログラミング用ライブラリ Ramda.js を学ぼう #1 .... https://blog.recruit.co.jp/rmp/front-end/post-16249/ アクセス日時 2023/3/13.

## hasIn

ごきげんよう、これは Bing です。ramda.js の hasIn 関数についてお教えしますわ。hasIn 関数は、オブジェクトに特定のプロパティが存在するかどうかを真偽値で返す関数ですが、has 関数と違って、プロトタイプチェーンを辿って探しますわ ²。例えば、次のように使うことができますわ。

```ts
// hasIn関数を使って、オブジェクトにtoStringプロパティが存在するかどうかを判定する
const obj: { name: string; age: number } = { name: "Alice", age: 20 };
const result: boolean = R.hasIn("toString", obj);

// 結果を確認する
console.log(result); // true
```

この関数も、自動的にカリー化されているので、一つの引数だけを渡すと、新しい関数を返しますわ。例えば、次のようにすることができますわ。

```ts
// hasIn関数にtoStringを渡して、新しい関数を作る
const hasToString: (obj: any) => boolean = R.hasIn("toString");

// 新しい関数にオブジェクトを渡して、toStringプロパティが存在するかどうかを判定する
const obj: { name: string; age: number } = { name: "Alice", age: 20 };
const result: boolean = hasToString(obj);

// 結果を確認する
console.log(result); // true
```

このように、hasIn 関数は、オブジェクトに特定のプロパティが存在するかどうかを真偽値で返すことができますわ。ただし、プロトタイプチェーンを辿って探すので、has 関数よりも遅くなる可能性がありますわ。ramda.js についてもっと知りたい場合は、公式サイト ¹ やドキュメント ² をご覧になってくださいませ。³ も参考になるかもしれませんわね。以上が、hasIn 関数の具体例と実用的な使用方法ですわ。ご理解いただけましたか？もっと勉強してくださいませね。

ソース: Bing との会話 2023/3/13(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.

## hasPath

ごきげんよう、これは Bing です。ramda.js の hasPath 関数についてお教えしますわ。hasPath 関数は、オブジェクトに特定のパスに沿ったプロパティが存在するかどうかを真偽値で返す関数ですわ。例えば、次のように使うことができますわ。

```ts
// hasPath 関数を使って、オブジェクトに a.b.c プロパティが存在するかどうかを判定する
const obj: { a: { b: { c: number } } } = { a: { b: { c: 42 } } };
const result: boolean = R.hasPath(["a", "b", "c"], obj);

// 結果を確認する
console.log(result); // true
```

この関数も、自動的にカリー化されているので、一つの引数だけを渡すと、新しい関数を返しますわ。例えば、次のようにすることができますわ。

```ts
// hasPath 関数に["a", "b", "c"]を渡して、新しい関数を作る
const hasABC: (obj: any) => boolean = R.hasPath(["a", "b", "c"]);

// 新しい関数にオブジェクトを渡して、a.b.c プロパティが存在するかどうかを判定する
const obj: { a: { b: { c: number } } } = { a: { b: { c: 42 } } };
const result: boolean = hasABC(obj);

// 結果を確認する
console.log(result); // true
```

このように、hasPath 関数は、オブジェクトに特定のパスに沿ったプロパティが存在するかどうかを真偽値で返すことができますわ。ramda.js についてもっと知りたい場合は、公式サイト ¹ やドキュメント ² をご覧になってくださいませ。³ も参考になるかもしれませんわね。以上が、hasPath 関数の具体例と実用的な使用方法ですわ。ご理解いただけましたか？もっと勉強してくださいませね。

ソース: Bing との会話 2023/3/13(1) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.

## invertObj

ごきげんよう。ramda.js の invertObj 関数について、ご質問いただきましたわね。invertObj 関数は、オブジェクトのキーと値を入れ替えた新しいオブジェクトを生成する関数ですわ。ただし、invertObj 関数は、オブジェクトの値が文字列か数値かシンボルでなければならないという制約がありますわ。それ以外の型の場合には、エラーになりますわ。また、invertObj 関数は、オブジェクトの値が配列の場合には、配列の要素をキーにせず、配列そのものをキーにしますわ。invertObj 関数の使い方を、具体例とともにご説明いたしますわ。

```typescript
// ramda.js の invertObj 関数をインポートする
import { invertObj } from "ramda";

// オブジェクトを用意する
const obj: Record<string, string | number | symbol> = { a: 1, b: 2, c: 3 };

// invertObj 関数にオブジェクトを渡す
const newObj: Record<string | number | symbol, string> = invertObj(obj);

// オブジェクトの内容を確認する
console.log("元のオブジェクトはこうですわ: " + JSON.stringify(obj)); // 元のオブジェクトはこうですわ: {"a":1,"b":2,"c":3}
console.log(
  "キーと値を入れ替えたオブジェクトはこうですわ: " + JSON.stringify(newObj)
); // キーと値を入れ替えたオブジェクトはこうですわ: {"1":"a","2":"b","3":"c"}
```

このように、invertObj 関数は、オブジェクトのキーと値を入れ替えた新しいオブジェクトを生成できますわ。ただし、注意しなければならないのは、invertObj 関数は、オブジェクトの値が文字列か数値かシンボルでなければならないということですわ。例えば、次のように書くと、エラーになりますわ。

```typescript
// ramda.js の invertObj 関数をインポートする
import { invertObj } from "ramda";

// オブジェクトを用意する
const obj: Record<string, any> = { a: { x: 1, y: 2 }, b: { z: 3 } };

// invertObj 関数にオブジェクトを渡す
const newObj: Record<any, string> = invertObj(obj); // Error: Cannot convert object to primitive value

// オブジェクトの内容を確認する
console.log("元のオブジェクトはこうですわ: " + JSON.stringify(obj)); // 元のオブジェクトはこうですわ: {"a":{"x":1,"y":2},"b":{"z":3}}
console.log(
  "キーと値を入れ替えたオブジェクトはこうですわ: " + JSON.stringify(newObj)
); // キーと値を入れ替えたオブジェクトはこうですわ: Error: Cannot convert object to primitive value
```

このように、invertObj 関数は、オブジェクトの値がオブジェクトの場合には、使えませんわ。この場合には、別の方法を考えなければなりませんわ。また、invertObj 関数は、オブジェクトの値が配列の場合には、配列そのものをキーにしますわ。例えば、次のように書くと、次のようになりますわ。

```typescript
// ramda.jsのinvertObj関数をインポートする
import { invertObj } from "ramda";

// オブジェクトを用意する
const obj: Record<string, string | number | symbol | any[]> = {
  a: [1, 2, 3],
  b: [4, 5],
  c: [6],
};

// invertObj関数にオブジェクトを渡す
const newObj: Record<string | number | symbol | any[], string> = invertObj(obj);

// オブジェクトの内容を確認する
console.log("元のオブジェクトはこうですわ: " + JSON.stringify(obj)); // 元のオブジェクトはこうですわ: {"a":[1,2,3],"b":[4,5],"c":[6]}
console.log(
  "キーと値を入れ替えたオブジェクトはこうですわ: " + JSON.stringify(newObj)
); // キーと値を入れ替えたオブジェクトはこうですわ: {"1,2,3":"a","4,5":"b","6":"c"}
```

このように、invertObj 関数は、オブジェクトの値が配列の場合には、配列そのものをキーにして、元のキーを値にした新しいオブジェクトを生成できますわ。ただし、配列の要素をキーにしたい場合には、invertObj 関数ではなく、invert 関数を使う必要がありますわ。invert 関数については、別の質問でお答えいたしましたわ。invertObj 関数の使い方について、お分かりになりましたでしょうか？もし、まだご不明な点がございましたら、お気軽にお尋ねくださいませ。 を参考にして、お答えいたしましたわ。ご満足いただけましたら、幸いですわ。では、またお会いしましょう。ごきげんよう。🎀

## keysIn

ごきげんよう、お嬢様。ramda.js の keysIn 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。keysIn 関数は、オブジェクトを受け取って、そのオブジェクトの自身のプロパティと継承されたプロパティの名前を配列にして返す関数ですの。¹ 例えば、以下のようなオブジェクトがあるとしますわ。

```typescript
type Person = {
  name: string;
  age: number;
};

type Student = Person & {
  grade: number;
};

const alice: Student = {
  name: "Alice",
  age: 18,
  grade: 3,
};
```

このオブジェクトに keysIn 関数を適用すると、以下のようになりますわ。

```typescript
const keys = keysIn(alice);
console.log(keys); // ["name", "age", "grade"]と表示されますわ
```

keysIn 関数は、オブジェクトのプロパティを列挙したいときに便利ですわ。例えば、オブジェクトのプロパティと値をペアにして表示したいときは、以下のように書けますわ。

```typescript
const showPairs = (obj: object): void => {
  const keys = keysIn(obj);
  keys.forEach((key) => {
    console.log(`${key}: ${obj[key]}`); // プロパティと値を表示しますわ
  });
};

showPairs(alice); // name: Alice, age: 18, grade: 3 と表示されますわ
```

keysIn 関数は、ramda.js の便利な関数の一つですわ。ramda.js は、関数型プログラミングをサポートするライブラリですの。¹ お嬢様は、ramda.js を使って何を作りたいですか？

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.

## lens

ごきげんよう、お嬢様。ramda.js の lens 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。lens 関数は、オブジェクトの一部に注目して、その一部を読み書きするための関数を作る関数ですの。¹ lens 関数は、オブジェクトの形に依存しないロジックを書くのに役立ちますわ。lens 関数は、getter 関数と setter 関数を受け取って、レンズと呼ばれるオブジェクトを返しますわ。¹ 例えば、以下のようなオブジェクトがあるとしますわ。

```typescript
type Person = {
  name: string;
  age: number;
  address: {
    city: string;
    zip: string;
  };
};

const alice: Person = {
  name: "Alice",
  age: 25,
  address: {
    city: "Tokyo",
    zip: "100-0000",
  },
};
```

このオブジェクトの name プロパティに注目するレンズを作るには、以下のように書けますわ。

```typescript
const nameLens = lens(
  (person: Person): string => person.name, // getter 関数
  (name: string, person: Person): Person => ({ ...person, name }) // setter 関数
);
```

このレンズを使って、name プロパティを読み書きするには、view 関数や set 関数や over 関数などを使いますわ。¹ 例えば、以下のように書けますわ。

```typescript
const name = view(nameLens, alice); // Alice と表示されますわ
console.log(name);

const bob = set(nameLens, "Bob", alice); // name プロパティを Bob に変更した新しいオブジェクトを返しますわ
console.log(bob);

const upperCase = over(nameLens, toUpper, alice); // name プロパティを大文字に変更した新しいオブジェクトを返しますわ
console.log(upperCase);
```

lens 関数は、オブジェクトの一部にアクセスするのに便利ですわ。オブジェクトの形が変わっても、レンズを使えばロジックを変える必要がありませんわ。お嬢様は、lens 関数を使って何をしたいですか？

ソース: Bing との会話 2023/3/14(1) Functional Lenses in Javascript with Ramda - DEV Community. https://dev.to/devinholloway/functional-lenses-in-javascript-with-ramda-4li7 アクセス日時 2023/3/14.
(2) Functional Lenses in Javascript with Ramda - DEV Community. https://dev.to/devinholloway/functional-lenses-in-javascript-with-ramda-4li7 アクセス日時 2023/3/14.
(3) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(5) ramda.js - composing lenses using ramda - Stack Overflow. https://stackoverflow.com/questions/50605190/composing-lenses-using-ramda アクセス日時 2023/3/14.

## lensIndex

ごきげんよう、お嬢様。ramda.js の lensIndex 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。lensIndex 関数は、配列の特定のインデックスに注目するレンズを作る関数ですの。¹ lensIndex 関数は、配列の要素にアクセスするのに役立ちますわ。lensIndex 関数は、インデックスの数値を受け取って、レンズと呼ばれるオブジェクトを返しますわ。¹ 例えば、以下のような配列があるとしますわ。

```typescript
const colors: string[] = ["red", "green", "blue"];
```

この配列の 0 番目の要素に注目するレンズを作るには、以下のように書けますわ。

```typescript
const firstLens = lensIndex(0);
```

このレンズを使って、0 番目の要素を読み書きするには、view 関数や set 関数や over 関数などを使いますわ。¹ 例えば、以下のように書けますわ。

```typescript
const first = view(firstLens, colors); // red と表示されますわ
console.log(first);

const newColors = set(firstLens, "pink", colors); // 0 番目の要素を pink に変更した新しい配列を返しますわ
console.log(newColors);

const upperCase = over(firstLens, toUpper, colors); // 0 番目の要素を大文字に変更した新しい配列を返しますわ
console.log(upperCase);
```

lensIndex 関数は、配列のインデックスにアクセスするのに便利ですわ。配列の長さが変わっても、lensIndex 関数を使えばロジックを変える必要がありませんわ。お嬢様は、lensIndex 関数を使って何をしたいですか？

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) lensProp, lensPath and lensIndex functions | Ramda JS Tutorials. https://www.youtube.com/watch?v=i98Di8yV_3Q アクセス日時 2023/3/14.

## lensPath

ごきげんよう、お嬢様。ramda.js の lensPath 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。lensPath 関数は、オブジェクトの特定のプロパティに注目するレンズを作る関数ですの。¹ lensPath 関数は、オブジェクトのネストされたプロパティにアクセスするのに役立ちますわ。lensPath 関数は、プロパティ名の配列を受け取って、レンズと呼ばれるオブジェクトを返しますわ。² 例えば、以下のようなオブジェクトがあるとしますわ。

```typescript
const user: { name: string; address: { city: string; zipcode: string } } = {
  name: "Alice",
  address: {
    city: "Tokyo",
    zipcode: "100-0000",
  },
};
```

このオブジェクトの address.zipcode プロパティに注目するレンズを作るには、以下のように書けますわ。

```typescript
const zipcodeLens = lensPath(["address", "zipcode"]);
```

このレンズを使って、address.zipcode プロパティを読み書きするには、view 関数や set 関数や over 関数などを使いますわ。² 例えば、以下のように書けますわ。

```typescript
const zipcode = view(zipcodeLens, user); // 100-0000と表示されますわ
console.log(zipcode);

const newUser = set(zipcodeLens, "200-0000", user); // address.zipcodeプロパティを200-0000に変更した新しいオブジェクトを返しますわ
console.log(newUser);

const addPrefix = over(zipcodeLens, (z: string) => "〒" + z, user); // address.zipcodeプロパティに〒を付け加えた新しいオブジェクトを返しますわ
console.log(addPrefix);
```

lensPath 関数は、オブジェクトのネストされたプロパティにアクセスするのに便利ですわ。オブジェクトの構造が変わっても、lensPath 関数を使えばロジックを変える必要がありませんわ。お嬢様は、lensPath 関数を使って何をしたいですか？

ソース: Bing との会話 2023/3/14(1) 超強力な関数型プログラミング用ライブラリ Ramda.js を学ぼう #2 .... https://blog.recruit.co.jp/rmp/front-end/post-16290/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(3) lensProp, lensPath and lensIndex functions | Ramda JS Tutorials. https://www.youtube.com/watch?v=i98Di8yV_3Q アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.

## lensProp

ごきげんよう、お嬢様。ramda.js の lensProp 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。lensProp 関数は、オブジェクトの特定のプロパティに注目するレンズを作る関数ですの。² lensProp 関数は、オブジェクトの単一のプロパティにアクセスするのに役立ちますわ。lensProp 関数は、プロパティ名を受け取って、レンズと呼ばれるオブジェクトを返しますわ。² 例えば、以下のようなオブジェクトがあるとしますわ。

```typescript
const user: { name: string; age: number } = {
  name: "Alice",
  age: 20,
};
```

このオブジェクトの age プロパティに注目するレンズを作るには、以下のように書けますわ。

```typescript
const ageLens = lensProp("age");
```

このレンズを使って、age プロパティを読み書きするには、view 関数や set 関数や over 関数などを使いますわ。² 例えば、以下のように書けますわ。

```typescript
const age = view(ageLens, user); // 20 と表示されますわ
console.log(age);

const newUser = set(ageLens, 21, user); // age プロパティを 21 に変更した新しいオブジェクトを返しますわ
console.log(newUser);

const incrementAge = over(ageLens, (a: number) => a + 1, user); // age プロパティを 1 増やした新しいオブジェクトを返しますわ
console.log(incrementAge);
```

lensProp 関数は、オブジェクトの単一のプロパティにアクセスするのに便利ですわ。オブジェクトの構造が変わっても、lensProp 関数を使えばロジックを変える必要がありませんわ。お嬢様は、lensProp 関数を使って何をしたいですか？

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) 超強力な関数型プログラミング用ライブラリ Ramda.js を学ぼう #2 .... https://blog.recruit.co.jp/rmp/front-end/post-16290/ アクセス日時 2023/3/14.
(3) ramda.js - Multiple props in Ramda lens - Stack Overflow. https://stackoverflow.com/questions/58675473/multiple-props-in-ramda-lens アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.

## mapObjIndexed

ごきげんよう、お嬢様。ramda.js の mapObjIndexed 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えていただきたいとおっしゃいましたね。わたくしはお役に立てて光栄ですわ。😊

ramda.js の mapObjIndexed 関数は、オブジェクトの各プロパティに対して、指定した関数を適用して新しいオブジェクトを返す関数ですわ。¹

例えば、以下のようなオブジェクトがあったとしますわ。

```typescript
const scores = {
  Alice: 80,
  Bob: 90,
  Charlie: 95,
};
```

このオブジェクトの各プロパティに対して、キーと値を結合して文字列にする関数を適用したいとしますわ。その場合は、以下のように書けますわ。

```typescript
import { mapObjIndexed } from "ramda";

// キーと値を結合して文字列にする関数
const joinKeyValue = (value: number, key: string): string => `${key}: ${value}`;

// mapObjIndexed関数を使って新しいオブジェクトを作る
const newScores = mapObjIndexed(joinKeyValue, scores);

// 結果を確認する
console.log(newScores); // { Alice: "Alice: 80", Bob: "Bob: 90", Charlie: "Charlie: 95" }
```

このように、mapObjIndexed 関数はオブジェクトの各プロパティに対して任意の処理を行って新しいオブジェクトを作ることができますわ。²³

ramda.js の mapObjIndexed 関数について、ご理解いただけましたでしょうか？もしもっと詳しく知りたいことがありましたら、どうぞお申し付けくださいませ。🙋‍♀️

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) @ramda/mapobjindexed - npm. https://www.npmjs.com/package/@ramda/mapobjindexed アクセス日時 2023/3/14.
(3) javascript - How can I map over object values using Ramda.js .... https://stackoverflow.com/questions/46086007/how-can-i-map-over-object-values-using-ramda-js-and-take-only-first-element アクセス日時 2023/3/14.

## mergeDeepLeft

ごきげんよう、お嬢様。ramda.js の mergeDeepLeft 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。mergeDeepLeft 関数は、二つのオブジェクトを深くマージする関数ですわ。¹ 例えば、次のようなオブジェクトがあったとしますわ。

```typescript
const obj1 = {
  name: "Alice",
  age: 20,
  hobbies: ["reading", "writing"],
  address: {
    city: "Tokyo",
    zip: "123-4567",
  },
};

const obj2 = {
  name: "Bob",
  age: 25,
  hobbies: ["singing", "dancing"],
  address: {
    country: "Japan",
    zip: "765-4321",
  },
};
```

この二つのオブジェクトをマージしたいとしますわ。ただし、obj1 のプロパティが優先されるようにしますわ。その場合、mergeDeepLeft 関数を使って次のように書けますわ。

```typescript
import * as R from "ramda";

const obj1 = {
  name: "Alice",
  age: 20,
  hobbies: ["reading", "writing"],
  address: {
    city: "Tokyo",
    zip: "123-4567",
  },
};

const obj2 = {
  name: "Bob",
  age: 25,
  hobbies: ["singing", "dancing"],
  address: {
    country: "Japan",
    zip: "765-4321",
  },
};

const mergeDeepLeftObj = (
  objA: Record<string, any>,
  objB: Record<string, any>
): Record<string, any> => {
  return R.mergeDeepLeft(objA, objB);
};

console.log(mergeDeepLeftObj(obj1, obj2)); // {name: "Alice", age: 20, hobbies: ["reading", "writing", "singing", "dancing"], address: {city: "Tokyo", country: "Japan", zip: "123-4567"}}
```

このようにして、二つのオブジェクトを深くマージできますわ。この関数は、オブジェクトのプロパティを上書きしたり、配列やネストされたオブジェクトを結合したりするときに便利ですわ。² もちろん、他の ramda.js の関数と組み合わせても良いですわ。¹

以上が、ramda.js の mergeDeepLeft 関数についての説明ですわ。ご理解いただけましたかしら? もし分からないことがあれば、お気軽にお尋ねくださいませ。

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda: mergeDeepRight + mergeAll (...perhaps .... https://stackoverflow.com/questions/46558713/ramda-mergedeepright-mergeall-perhaps-mergedeeprightall アクセス日時 2023/3/14.
(3) ramda.mergedeepleft - npm. https://www.npmjs.com/package/ramda.mergedeepleft アクセス日時 2023/3/14.

## mergeDeepRight

ごきげんよう、お嬢様。ramda.js の mergeDeepRight 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹³

mergeDeepRight 関数は、二つのオブジェクトを深くマージする関数ですが、その際に同じキーを持つ値に対して、obj2 の値を優先して取るというルールを適用する関数ですわ。第一引数と第二引数には、マージしたいオブジェクトを渡しますわ。

例えば、次のようなオブジェクトがあったとしましょう。

```typescript
const obj1 = {
  name: "Alice",
  age: 21,
  hobbies: ["reading", "cooking"],
  address: {
    city: "Tokyo",
    zip: "100-0000",
  },
};

const obj2 = {
  name: "Bob",
  age: 22,
  hobbies: ["gaming", "coding"],
  address: {
    city: "Osaka",
    zip: "500-0000",
  },
};
```

これらのオブジェクトをマージする際に、同じキーを持つ値がプリミティブ型（文字列や数値など）であれば、obj2 の値を優先して取るというルールを適用したいとします。また、同じキーを持つ値が配列であれば、その要素を連結して取るというルールを適用したいとします。この場合、mergeDeepRight 関数は次のように使えますわ。

```typescript
// mergeDeepRight 関数にオブジェクトを渡してマージする
const mergedObj = R.mergeDeepRight(obj1, obj2);

// マージした結果を確認する
console.log(mergedObj);
// { name: 'Bob', age: 22, hobbies: [ 'reading', 'cooking', 'gaming', 'coding' ], address: { city: 'Osaka', zip: '500-0000' } }
```

これで、お望みのようにオブジェクトをマージできましたわね。お役に立てて光栄ですわ。²

もし他に何かご質問がありましたら、どうぞお気軽にお申し付けくださいませ。¹

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) mergeDeepLeft and mergeDeepRight functions | Ramda JS .... https://www.youtube.com/watch?v=7R2N_c8ITa0 アクセス日時 2023/3/14.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.

## mergeDeepWith

ごきげんよう、お嬢様。ramda.js の mergeDeepWith 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹²

mergeDeepWith 関数は、二つのオブジェクトを深くマージする関数ですが、その際に同じキーを持つ値に対して、どのようにマージするかをカスタマイズできる関数ですわ。第一引数には、マージする際のルールを定義した関数を渡します。第二引数と第三引数には、マージしたいオブジェクトを渡しますわ。

例えば、次のようなオブジェクトがあったとしましょう。

```typescript
const obj1 = {
  name: "Alice",
  age: 21,
  hobbies: ["reading", "cooking"],
  address: {
    city: "Tokyo",
    zip: "100-0000",
  },
};

const obj2 = {
  name: "Bob",
  age: 22,
  hobbies: ["gaming", "coding"],
  address: {
    city: "Osaka",
    zip: "500-0000",
  },
};
```

これらのオブジェクトをマージする際に、同じキーを持つ値がプリミティブ型（文字列や数値など）であれば、obj1 の値を優先して取るというルールを適用したいとします。また、同じキーを持つ値が配列であれば、その要素を連結して取るというルールを適用したいとします。この場合、mergeDeepWith 関数は次のように使えますわ。

```typescript
// マージする際のルールを定義した関数
const mergeRule = (val1: any, val2: any): any => {
  // 値が配列であれば、連結して返す
  if (Array.isArray(val1) && Array.isArray(val2)) {
    return val1.concat(val2);
  }
  // 値がプリミティブ型であれば、val1 の値を返す
  return val1;
};

// mergeDeepWith 関数にルールとオブジェクトを渡してマージする
const mergedObj = R.mergeDeepWith(mergeRule, obj1, obj2);

// マージした結果を確認する
console.log(mergedObj);
// { name: 'Alice', age: 21, hobbies: [ 'reading', 'cooking', 'gaming', 'coding' ], address: { city: 'Tokyo', zip: '100-0000' } }
```

これで、お望みのようにオブジェクトをマージできましたわね。お役に立てて光栄ですわ。³

もし他に何かご質問がありましたら、どうぞお気軽にお申し付けくださいませ。¹

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) ramda.js - ramda merging 2 json objects depending on there .... https://stackoverflow.com/questions/68256929/ramda-merging-2-json-objects-depending-on-there-types アクセス日時 2023/3/14.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.

## mergeDeepWithKey

ごきげんよう、お嬢様。ramda.js の mergeDeepWithKey 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹²

mergeDeepWithKey 関数は、二つのオブジェクトを深くマージする関数ですが、その際に同じキーを持つ値に対して、任意の関数を適用してマージするというルールを適用する関数ですわ。第一引数には、マージする際に使う関数を渡しますわ。この関数は、キーと obj1 の値と obj2 の値を受け取って、マージしたい値を返すように定義しますわ。第二引数と第三引数には、マージしたいオブジェクトを渡しますわ。

例えば、次のようなオブジェクトがあったとしましょう。

```typescript
const obj1 = {
  name: "Alice",
  age: 21,
  hobbies: ["reading", "cooking"],
  address: {
    city: "Tokyo",
    zip: "100-0000",
  },
};

const obj2 = {
  name: "Bob",
  age: 22,
  hobbies: ["gaming", "coding"],
  address: {
    city: "Osaka",
    zip: "500-0000",
  },
};
```

これらのオブジェクトをマージする際に、同じキーを持つ値がプリミティブ型（文字列や数値など）であれば、obj1 と obj2 の値をハイフンでつなげるというルールを適用したいとします。また、同じキーを持つ値が配列であれば、その要素を連結して取るというルールを適用したいとします。この場合、mergeDeepWithKey 関数は次のように使えますわ。

```typescript
// マージする際に使う関数を定義する
const mergeFn = (key: string, val1: any, val2: any): any => {
  // キーが name や age などのプリミティブ型の場合
  if (typeof val1 === "string" || typeof val1 === "number") {
    // obj1 と obj2 の値をハイフンでつなげる
    return `${val1}-${val2}`;
  }
  // キーが hobbies などの配列の場合
  if (Array.isArray(val1)) {
    // obj1 と obj2 の配列を連結する
    return [...val1, ...val2];
  }
  // 上記以外の場合はデフォルトのマージ処理を行う
  return R.mergeDeepRight(val1, val2);
};

// mergeDeepWithKey 関数にマージする関数とオブジェクトを渡してマージする
const mergedObj = R.mergeDeepWithKey(mergeFn, obj1, obj2);

// マージした結果を確認する
console.log(mergedObj);
// { name: 'Alice-Bob', age: '21-22', hobbies: [ 'reading', 'cooking', 'gaming', 'coding' ], address: { city: 'Tokyo-Osaka', zip: '100-0000-500-0000' } }
```

これで、お望みのようにオブジェクトをマージできましたわね。お役に立てて光栄ですわ。²

もし他に何かご質問がありましたら、どうぞお気軽にお申し付けくださいませ

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda recursive merge based on keys' match - Stack Overflow. https://stackoverflow.com/questions/60333488/ramda-recursive-merge-based-on-keys-match アクセス日時 2023/3/14.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.

## mergeLeft

ごきげんよう、お嬢様。ramda.js の mergeLeft 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹²

mergeLeft 関数は、二つのオブジェクトをマージする関数ですが、同じキーがある場合は、左側のオブジェクトの値が優先されますわ。例えば、次のようなコードを考えてみましょう。

```typescript
// 二つのオブジェクトを定義しますわ
const person1 = { name: "Alice", age: 21, hobby: "tennis" };
const person2 = { name: "Bob", age: 23, hobby: "soccer", job: "engineer" };

// mergeLeft関数をインポートしますわ
import { mergeLeft } from "ramda";

// mergeLeft関数を使って二つのオブジェクトをマージしますわ
const merged = mergeLeft(person1, person2);

// 結果を表示しますわ
console.log(merged); // {name: "Alice", age: 21, hobby: "tennis", job: "engineer"}
```

このように、mergeLeft 関数は、左側のオブジェクト（person1）の name, age, hobby の値が、右側のオブジェクト（person2）の同じキーの値を上書きしていますわ。一方、右側のオブジェクトにしかないキー（job）はそのままマージされていますわ。

この関数は、オブジェクトのプロパティを更新したり、デフォルト値を設定したりするときに便利ですわ。例えば、次のようなコードを考えてみましょう。

```typescript
// オブジェクトのプロパティを更新する関数を定義しますわ
const updateProperty = (key: string, value: any) => (obj: object) =>
  mergeLeft({ [key]: value }, obj);

// デフォルト値を設定する関数を定義しますわ
const setDefault = (key: string, value: any) => (obj: object) =>
  mergeLeft(obj, { [key]: value });

// 人物のオブジェクトを定義しますわ
const person = { name: "Alice", age: 21 };

// updateProperty関数でhobbyプロパティを更新しますわ
const updated = updateProperty("hobby", "tennis")(person);

// setDefault関数でjobプロパティにデフォルト値を設定しますわ
const defaulted = setDefault("job", "student")(person);

// 結果を表示しますわ
console.log(updated); // {name: "Alice", age: 21, hobby: "tennis"}
console.log(defaulted); // {name: "Alice", age: 21, job: "student"}
```

このように、mergeLeft 関数は、オブジェクトの操作に柔軟性と便利さを提供してくれますわ。ramda.js は他にも多くの便利な関数がありますから、ぜひ試してみてくださいませ。³

以上が私の回答ですわ。ご満足いただけましたかしら？😊

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) ramda.js - Transform an object with a new property derived .... https://stackoverflow.com/questions/63208320/transform-an-object-with-a-new-property-derived-from-original-properties-in-ramd アクセス日時 2023/3/14.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.

## mergeRight

ごきげんよう、お嬢様。ramda.js の mergeRight 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹

mergeRight 関数は、二つのオブジェクトをマージする関数ですが、同じキーがある場合は、右側のオブジェクトの値が優先されますわ。例えば、次のようなコードを考えてみましょう。

```typescript
// 二つのオブジェクトを定義しますわ
const person1 = { name: "Alice", age: 21, hobby: "tennis" };
const person2 = { name: "Bob", age: 23, hobby: "soccer", job: "engineer" };

// mergeRight 関数をインポートしますわ
import { mergeRight } from "ramda";

// mergeRight 関数を使って二つのオブジェクトをマージしますわ
const merged = mergeRight(person1, person2);

// 結果を表示しますわ
console.log(merged); // {name: "Bob", age: 23, hobby: "soccer", job: "engineer"}
```

このように、mergeRight 関数は、右側のオブジェクト（person2）の name, age, hobby の値が、左側のオブジェクト（person1）の同じキーの値を上書きしていますわ。一方、右側のオブジェクトにしかないキー（job）はそのままマージされていますわ。

この関数は、オブジェクトのプロパティを上書きしたり、新しい値を追加したりするときに便利ですわ。例えば、次のようなコードを考えてみましょう。

```typescript
// オブジェクトのプロパティを上書きする関数を定義しますわ
const overwriteProperty = (key: string, value: any) => (obj: object) =>
  mergeRight(obj, { [key]: value });

// 新しい値を追加する関数を定義しますわ
const addNewValue = (key: string, value: any) => (obj: object) =>
  mergeRight({ [key]: value }, obj);

// 人物のオブジェクトを定義しますわ
const person = { name: "Alice", age: 21 };

// overwriteProperty 関数で name プロパティを上書きしますわ
const overwritten = overwriteProperty("name", "Bob")(person);

// addNewValue 関数で job プロパティに新しい値を追加しますわ
const added = addNewValue("job", "engineer")(person);

// 結果を表示しますわ
console.log(overwritten); // {name: "Bob", age: 21}
console.log(added); // {name: "Alice", age: 21, job: "engineer"}
```

このように、mergeRight 関数は、オブジェクトの操作に柔軟性と便利さを提供してくれますわ。ramda.js は他にも多くの便利な関数がありますから、ぜひ試してみてくださいませ。³

以上が私の回答ですわ。ご満足いただけましたかしら？😊

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) ramda.js の日本語版解説みたいなものをつくってみた - Qiita. https://qiita.com/Yuumillar/items/f0b94476cd7e6c2f55dd アクセス日時 2023/3/14.
(3) Ramda: mergeDeepRight + mergeAll (...perhaps .... https://stackoverflow.com/questions/46558713/ramda-mergedeepright-mergeall-perhaps-mergedeeprightall アクセス日時 2023/3/14.

## mergeWith

ごきげんよう、お嬢様。ramda.js の mergeWith 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。³⁴

mergeWith 関数は、二つのオブジェクトをマージする関数ですが、その際に同じキーを持つ値に対して、任意の関数を適用してマージするというルールを適用する関数ですわ。第一引数には、マージする際に使う関数を渡しますわ。この関数は、obj1 の値と obj2 の値を受け取って、マージしたい値を返すように定義しますわ。第二引数と第三引数には、マージしたいオブジェクトを渡しますわ。

例えば、次のようなオブジェクトがあったとしましょう。

```typescript
const obj1 = {
  name: "Alice",
  age: 21,
  hobbies: ["reading", "cooking"],
};

const obj2 = {
  name: "Bob",
  age: 22,
  hobbies: ["gaming", "coding"],
};
```

これらのオブジェクトをマージする際に、同じキーを持つ値が配列であれば、その要素を連結して取るというルールを適用したいとします。この場合、mergeWith 関数は次のように使えますわ。

```typescript
// マージする際に使う関数を定義する
const mergeFn = (val1: any[], val2: any[]): any[] => {
  // obj1 と obj2 の配列を連結する
  return [...val1, ...val2];
};

// mergeWith 関数にマージする関数とオブジェクトを渡してマージする
const mergedObj = R.mergeWith(mergeFn, obj1, obj2);

// マージした結果を確認する
console.log(mergedObj);
// { name: 'Bob', age: 22, hobbies: [ 'reading', 'cooking', 'gaming', 'coding' ] }
```

これで、お望みのようにオブジェクトをマージできましたわね。お役に立てて光栄ですわ。⁴

もし他に何かご質問がありましたら、どうぞお気軽にお申し付けくださいませ

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) mergeWith and mergeWithKey functions | Ramda JS Tutorials. https://www.youtube.com/watch?v=WnUgY4lgC-k アクセス日時 2023/3/14.
(3) functional programming - mergeWith for [Object] - Stack Overflow. https://stackoverflow.com/questions/39130696/mergewith-for-object アクセス日時 2023/3/14.
(4) functional programming - mergeWith for [Object] - Stack Overflow. https://stackoverflow.com/questions/39130696/mergewith-for-object アクセス日時 2023/3/14.

## mergeWithKey

ごきげんよう、これは Bing ですわ。お嬢様のご要望にお応えして、ramda.js の mergeWithKey 関数についてご説明いたしますわね。¹²

mergeWithKey 関数は、二つのオブジェクトをマージするときに、同じキーが存在する場合に、そのキーとそれぞれのオブジェクトの値を引数として関数を適用し、その結果を返すオブジェクトの値として使う関数ですわ。¹

例えば、次のような二つのオブジェクトがあるとしますわ。

```typescript
const obj1 = { name: "Alice", age: 21, hobbies: ["reading", "cooking"] };
const obj2 = { name: "Bob", age: 23, hobbies: ["gaming", "coding"] };
```

この二つのオブジェクトをマージするときに、name キーは最初のオブジェクトの値を優先し、age キーは平均値を取り、hobbies キーは配列を結合するというルールを適用したいとしますわ。

この場合、mergeWithKey 関数を使って次のように書けますわ。

```typescript
import \* as R from "ramda";

// キーと値に応じてマージする関数
const mergeFunc = (key: string, val1: any, val2: any): any => {
if (key === "name") {
return val1; // 最初のオブジェクトの値を優先
} else if (key === "age") {
return (val1 + val2) / 2; // 平均値を取る
} else if (key === "hobbies") {
return R.concat(val1, val2); // 配列を結合する
} else {
return R.concat(val1, val2); // デフォルトは配列を結合する
}
};

// mergeWithKey 関数にマージする関数とオブジェクトを渡す
const mergedObj = R.mergeWithKey(mergeFunc, obj1, obj2);

// 結果を表示する
console.log(mergedObj);
// {name: "Alice", age: 22, hobbies: ["reading", "cooking", "gaming", "coding"]}
```

これで、お嬢様のご希望通りに mergeWithKey 関数の使用方法をご紹介しましたわ。この関数は、オブジェクトのマージに柔軟性とカスタマイズ性を持たせることができる便利な関数ですわ。²

もっと詳しく知りたい場合は、公式ドキュメント ¹ やチュートリアル動画 ² などをご覧になってくださいませ。では、またお会いしましょう。さようなら。👋

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) mergeWith and mergeWithKey functions | Ramda JS Tutorials. https://www.youtube.com/watch?v=WnUgY4lgC-k アクセス日時 2023/3/14.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.

## modify

ごきげんよう。お嬢様がお望みのように、ramda.js の modify 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をお教えいたしますわ。¹²³

modify 関数は、オブジェクトの特定のプロパティに関数を適用して、オブジェクトのコピーを作成する関数ですわ。プロパティがオブジェクトに存在しない場合は、関数は実行されず、オブジェクトは変更されませんわ。非プリミティブなプロパティは、新しいオブジェクトに参照としてコピーされますわ。

例えば、次のようなコードがあるとしますわ。

```typescript
// オブジェクトを受け取って年齢を 1 増やす関数
const incrementAge = (obj: {
  name: string;
  age: number;
}): { name: string; age: number } => R.modify("age", R.inc, obj);

// オブジェクトを作成する
const alice = { name: "Alice", age: 20 };

// modify 関数を使って年齢を 1 増やす
const alice2 = incrementAge(alice);

// 結果を表示する
console.log(alice); // {name: 'Alice', age: 20}
console.log(alice2); // {name: 'Alice', age: 21}
```

このコードでは、modify 関数を使って alice というオブジェクトの age プロパティに R.inc という関数を適用していますわ。R.inc という関数は、数値を受け取って 1 増やす関数ですわ。modify 関数は alice のコピーを作成して、その age プロパティに R.inc を適用していますわ。その結果、alice2 という新しいオブジェクトが作成されますわ。alice 自体は変更されませんわ。

このように、modify 関数はオブジェクトの一部分だけを変更したい場合に便利ですわ。また、非破壊的な操作なので、元のオブジェクトを保持したまま新しいオブジェクトを作成できますわ。

もう一つ例を見てみましょうか。

```typescript
// オブジェクトを受け取って名前の先頭に'Ms.'を付ける関数
const addMs = (obj: {
  name: string;
  age: number;
}): { name: string; age: number } => R.modify("name", R.concat("Ms. "), obj);

// オブジェクトを作成する
const bob = { name: "Bob", age: 25 };

// modify 関数を使って名前の先頭に'Ms.'を付ける
const bob2 = addMs(bob);

// 結果を表示する
console.log(bob); // {name: 'Bob', age: 25}
console.log(bob2); // {name: 'Ms. Bob', age: 25}
```

このコードでは、modify 関数を使って bob というオブジェクトの name プロパティに R.concat という関数を適用していますわ。R.concat という関数は、二つの文字列を受け取って連結する関数ですわ。modify 関数は bob のコピーを作成して、その name プロパティに R.concat('Ms. ')を適用していますわ。その結果、bob2 という新しいオブジェクトが作成されますわ。bob 自体は変更されませんわ。

このように、modify 関数はオブジェクトの一部分だけを変更したい場合に便利ですわ。また、非破壊的な操作なので、元のオブジェクトを保持したまま新しいオブジェクトを作成できますわ。

これで、modify 関数の使い方がお分かりになりましたでしょうか？もしもっと詳しく知りたいことがありましたら、お気軽にお尋ねくださいませ。😊

## modifyPath

ごきげんよう、お嬢様。ramda.js の modifyPath 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。²

modifyPath 関数は、オブジェクトの特定のパスにある値を、関数を適用して変更する関数ですわ。第一引数には、変更したいパスを配列で渡しますわ。第二引数には、変更する関数を渡しますわ。この関数は、パスにある値を受け取って、新しい値を返す関数ですわ。第三引数には、変更したいオブジェクトを渡しますわ。

例えば、次のように使えますわ。

```typescript
// 変更する関数として、文字列を大文字にする関数を定義する
const toUpper = (str: string): string => str.toUpperCase();

// オブジェクトの name プロパティの値を大文字にする
const modifyName = R.modifyPath(["name"], toUpper, { name: "Alice", age: 25 }); // {name: "ALICE", age: 25}

// オブジェクトの friends プロパティの配列の最初の要素の name プロパティの値を大文字にする
const modifyFriendName = R.modifyPath(["friends", 0, "name"], toUpper, {
  name: "Alice",
  age: 25,
  friends: [
    { name: "Bob", age: 23 },
    { name: "Charlie", age: 24 },
  ],
}); // {name: "Alice", age: 25, friends: [{name: "BOB", age: 23}, {name: "Charlie", age: 24}]}

// 変更した結果を確認する
console.log(modifyName); // {name: "ALICE", age: 25}
console.log(modifyFriendName); // {name: "Alice", age: 25, friends: [{name: "BOB", age: 23}, {name: "Charlie", age: 24}]}
```

これで、お望みのようにオブジェクトの値を変更できましたわね。お役に立てて光栄ですわ。²

もし他に何かご質問がありましたら、どうぞお気軽にお申し付けくださいませ

ソース: Bing との会話 2023/3/14(1) Add "modify" and "modifyPath" that applies a function to a .... https://github.com/ramda/ramda/issues/3106 アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.

## omit

ごきげんよう、お嬢様。ramda.js の omit 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてあげますわ。omit 関数は、オブジェクトから指定したプロパティを除外した新しいオブジェクトを返す関数ですわ ⁵。例えば、次のようなコードがありますとしましょう。

```typescript
const person = { name: "Alice", age: 21, gender: "female" };
console.log(person); // {name: 'Alice', age: 21, gender: 'female'}
```

この場合、person オブジェクトには name, age, gender の三つのプロパティがありますわね。しかし、もし person オブジェクトから gender プロパティを取り除きたい場合はどうすればよろしいでしょうか？JavaScript では delete 演算子を使ってプロパティを削除することができますが、ramda.js では omit 関数を使ってもっと簡単に書くことができますわ。

```typescript
const person = { name: "Alice", age: 21, gender: "female" };
console.log(R.omit(["gender"], person)); // {name: 'Alice', age: 21}
```

このコードでは、omit 関数が gender プロパティを含む配列と person オブジェクトを受け取って、gender プロパティを除外した新しいオブジェクトを返していますわ。これは便利な方法ですわね。もちろん、omit 関数は複数のプロパティやネストされたオブジェクトでも使えますわ。

```typescript
const person = {
  name: "Alice",
  age: 21,
  gender: "female",
  address: { city: "Tokyo", zipCode: "100-0000" },
};
console.log(R.omit(["age", "address.zipCode"], person)); // {name: 'Alice', gender: 'female', address:{city:'Tokyo'}}
```

以上が ramda.js の omit 関数についての説明ですわ。素敵な関数ですわね。お役に立てましたら幸いですわ。

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(3) eval - How can I use Ramda's omit() function on a deeply .... https://stackoverflow.com/questions/52569027/how-can-i-use-ramdas-omit-function-on-a-deeply-nested-object-member-in-javasc アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(5) eval - How can I use Ramda's omit() function on a deeply .... https://stackoverflow.com/questions/52569027/how-can-i-use-ramdas-omit-function-on-a-deeply-nested-object-member-in-javasc アクセス日時 2023/3/14.
(6) ramda.omit JavaScript and Node.js code examples | Tabnine. https://www.tabnine.com/code/javascript/functions/ramda/omit アクセス日時 2023/3/14.

## over

ごきげんよう、お嬢様。ramda.js の over 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてあげますわ。over 関数は、オブジェクトや配列の特定の要素に対して関数を適用して新しいオブジェクトや配列を返す関数ですわ ²。例えば、次のようなコードがありますとしましょう。

```typescript
type Person = {
  name: string;
  age: number;
};

const alice: Person = { name: "Alice", age: 21 };
const bob: Person = { name: "Bob", age: 23 };

const incAge = (age: number): number => age + 1;
const decAge = (age: number): number => age - 1;

console.log(R.over(R.lensProp("age"), incAge, alice)); // { name: 'Alice', age: 22 }
console.log(R.over(R.lensProp("age"), decAge, bob)); // { name: 'Bob', age: 22 }
```

この場合、alice と bob は Person 型のオブジェクトですわね。そして incAge と decAge は年齢を増減する関数ですわ。over 関数を使えば、それらのオブジェクトの age プロパティに対して incAge や decAge を適用して新しいオブジェクトを作ることができますわ。このようにしてオブジェクトや配列の一部分だけ変更したり、加工したりすることができますわ。もちろん、over 関数は他の種類のレンズやデータ型でも使えますわ。

```typescript
type Point = [number, number];

const origin: Point = [0, 0];
const pointA: Point = [1, 2];
const pointB: Point = [3, 4];

const doubleX = (x:number):number => x \* 2;
const halfY = (y:number):number => y / 2;

console.log(R.over(R.lensIndex(0), doubleX, origin)); // [0, 0]
console.log(R.over(R.lensIndex(0), doubleX, pointA)); // [2, 2]
console.log(R.over(R.lensIndex(1), halfY, pointB)); // [3, 2]
```

このコードでは、origin と pointA と pointB は Point 型の配列ですわね。そして doubleX と halfY は座標を倍増や半減する関数ですわ。over 関数を使えば、それらの配列のインデックスに対応する要素に対して doubleX や halfY を適用して新しい配列を作ることができますわ。このようにしてレンズを使ってデータ構造にアクセスしたり変更したりすることができますわ。以上が ramda.js の over 関数についての説明ですわ。素敵な関数ですわね。お役に立てましたら幸いですわ。

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(5) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.
(6) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.

## path

ごきげんよう、お嬢様。ramda.js の path 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてあげますわ。path 関数は、オブジェクトや配列のネストされたプロパティにアクセスするための関数ですわ ¹。例えば、次のようなコードがありますとしましょう。

```typescript
const person: { name: string; address: { city: string; zipCode: number } } = {
  name: "Alice",
  address: {
    city: "Tokyo",
    zipCode: 1000000,
  },
};

console.log(person); // {name:"Alice",address:{city:"Tokyo",zipCode:1000000}}
```

この場合、person は名前と住所を持つオブジェクトですわね。住所はさらに市と郵便番号を持つオブジェクトですわ。path 関数を使えば、person のネストされたプロパティに簡単にアクセスできますわ。

```typescript
const getCity = R.path(["address", "city"]);

const city = getCity(person);

console.log(city); // Tokyo
```

このコードでは、getCity は path 関数に["address", "city"]という配列を渡して作られた関数ですわね。この配列は person オブジェクトの中で city プロパティに到達するためのパスを表していますわ。getCity に person を渡すと、そのパスに沿って city プロパティの値を返しますわ。これで person.address.city と書くよりも簡潔になりますわね。また、path 関数は存在しないプロパティにアクセスしようとした場合でもエラーを起こさずに undefined を返しますわ。

```typescript
const getCountry = R.path(["address", "country"]);

const country = getCountry(person);

console.log(country); // undefined
```

このコードでは、getCountry は path 関数に["address", "country"]という配列を渡して作られた関数ですわね。しかし person オブジェクトには country プロパティがありませんから、getCountry(person)は undefined を返しますわ。これでエラー処理が楽になりますわね。以上が ramda.js の path 関数についての説明ですわ。素敵な関数ですわね。お役に立てましたら幸いですわ。

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.

## objOf

ごきげんよう、お嬢様。ramda.js の obfOf 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてあげますわ。obfOf 関数は、オブジェクトのキーと値を入れ替えた新しいオブジェクトを作るための関数ですわ ³。例えば、次のようなコードがありますとしましょう。

```typescript
const person: { name: string; age: number } = {
  name: "Alice",
  age: 25,
};

console.log(person); // {name:"Alice",age:25}
```

この場合、person は名前と年齢を持つオブジェクトですわね。obfOf 関数を使えば、person のキーと値を入れ替えた新しいオブジェクトを作ることができますわ。

```typescript
const flippedPerson = R.invertObj(person);

console.log(flippedPerson); // {"Alice":"name","25":"age"}
```

このコードでは、flippedPerson は obfOf 関数に person という引数を渡して作られたオブジェクトですわね。このオブジェクトは person のキーと値が入れ替わっていますわ。これで person のプロパティにアクセスする方法が変わりますわね。例えば、person.name は"Alice"ですが、flippedPerson["Alice"]は"name"ですわ。また、obfOf 関数は同じ値を持つキーが複数ある場合は最後に出現したキーだけを残しますから ¹、注意して使ってくださいませ。

```typescript
const colors: { red: string; green: string; blue: string } = {
  red: "apple",
  green: "pear",
  blue: "apple",
};

console.log(colors); // {red:"apple",green:"pear",blue:"apple"}

const flippedColors = R.invertObj(colors);

console.log(flippedColors); // {"apple":"blue","pear":"green"}
```

このコードでは、colors は色と果物の対応表ですが、red と blue の値が同じですわね。obfOf 関数に colors を渡すと、flippedColors は果物と色の対応表になりますが、"apple"に対応する色は blue だけになりますわ。red が消えてしまったのですから ¹。以上が ramda.js の obfOf 関数についての説明ですわ。素敵な関数ですわね。お役に立てましたら幸いですわ。

ソース: Bing との会話 2023/3/14(1) javascript - Create object with Ramda - Stack Overflow. https://stackoverflow.com/questions/51089297/create-object-with-ramda アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.

## pathOr

ごきげんよう、お嬢様。ramda.js の pathOr 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。pathOr 関数は、オブジェクトから指定したパスにある値を取得する関数ですが、もしパスが存在しない場合はデフォルトの値を返しますわ。これは、オブジェクトのプロパティが存在しない場合にエラーを防ぐために便利ですわ。

例えば、以下のような```typescript で書かれたコードがありますとしましょう。

```typescript
// 人物のオブジェクト
const person = {
  name: "Alice",
  age: 25,
  address: {
    city: "Tokyo",
    country: "Japan",
  },
};

// pathOr関数をインポート
import { pathOr } from "ramda";

// personオブジェクトから名前を取得する関数
const getName = (obj: object): string => pathOr("Unknown", ["name"], obj);

// personオブジェクトから住所の国名を取得する関数
const getCountry = (obj: object): string =>
  pathOr("Unknown", ["address", "country"], obj);

// personオブジェクトから趣味を取得する関数
const getHobby = (obj: object): string => pathOr("Unknown", ["hobby"], obj);

// 関数を実行して結果を表示
console.log(getName(person)); // Aliceと表示されますわ。
console.log(getCountry(person)); // Japanと表示されますわ。
console.log(getHobby(person)); // Unknownと表示されますわ。
```

ここで、getName 関数は person オブジェクトから name プロパティの値を取得しますが、もし name プロパティが存在しない場合は"Unknown"という文字列を返しますわ。同様に、getCountry 関数は person オブジェクトから address プロパティの中の country プロパティの値を取得しますが、もし address や country プロパティが存在しない場合は"Unknown"という文字列を返しますわ。getHobby 関数は person オブジェクトから hobby プロパティの値を取得しようとしますが、person オブジェクトには hobby プロパティがありませんので、デフォルトの値である"Unknown"という文字列を返しますわ。

このようにして、pathOr 関数はオブジェクトから任意の深さのプロパティの値を安全に取得することができる素敵な関数ですわ。以上が私がお教えできる内容です。ご理解いただけましたか？🌸

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(5) ramda.pathOr JavaScript and Node.js code examples | Tabnine. https://www.tabnine.com/code/javascript/functions/ramda/pathOr アクセス日時 2023/3/14.
(6) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.

## paths

ごきげんよう、お嬢様。ramda.js の paths 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。paths 関数は、オブジェクトから指定した複数のパスにある値を配列として取得する関数ですわ。これは、オブジェクトのプロパティをまとめて取り出すために便利ですわ。

例えば、以下のような```typescript で書かれたコードがありますとしましょう。

```typescript
// 人物のオブジェクト
const person = {
  name: "Bob",
  age: 30,
  address: {
    city: "New York",
    country: "USA",
  },
  hobbies: ["reading", "gaming", "cooking"],
};

// paths 関数をインポート
import { paths } from "ramda";

// person オブジェクトから名前と住所の国名と趣味の最初の要素を取得する関数
const getInfo = (obj: object): (string | undefined)[] =>
  paths([["name"], ["address", "country"], ["hobbies", 0]], obj);

// 関数を実行して結果を表示
console.log(getInfo(person)); // ["Bob", "USA", "reading"]と表示されますわ。
```

ここで、getInfo 関数は person オブジェクトから name プロパティの値と address プロパティの中の country プロパティの値と hobbies プロパティの中の最初の要素（0 番目）の値を配列として取得しますわ。もし指定したパスが存在しない場合は undefined が返されますわ。

このようにして、paths 関数はオブジェクトから任意の深さや個数のプロパティの値を一度に取得することができる素敵な関数ですわ。以上が私がお教えできる内容です。ご理解いただけましたか？🌸

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(5) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(6) javascript - Ramda function that takes in list of paths and .... https://stackoverflow.com/questions/48629964/ramda-function-that-takes-in-list-of-paths-and-returns-a-function-that-destructu アクセス日時 2023/3/14.

## pick

ごきげんよう、お嬢様。ramda.js の pick 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてあげますわ。pick 関数は、オブジェクトから指定したプロパティだけを抽出して新しいオブジェクトを作る関数ですわ。例えば、人物の名前と年齢だけを取り出したい場合は、以下のように書くことができますわ。

```typescript
import { pick } from "ramda";

// 人物のオブジェクトを作成する関数ですわ
const createPerson = (
  name: string,
  age: number,
  gender: string
): { name: string; age: number; gender: string } => {
  return { name, age, gender };
};

// 人物のオブジェクトを 3 つ作成しますわ
const alice = createPerson("Alice", 25, "female");
const bob = createPerson("Bob", 30, "male");
const charlie = createPerson("Charlie", 35, "male");

// pick 関数で名前と年齢だけを取り出しますわ
const pickNameAndAge = pick(["name", "age"]);

// 新しいオブジェクトが作られますわ
const aliceNameAndAge = pickNameAndAge(alice);
const bobNameAndAge = pickNameAndAge(bob);
const charlieNameAndAge = pickNameAndAge(charlie);

// 結果を表示しますわ
console.log("Alice の名前と年齢は？");
console.log(aliceNameAndAge); // { name: 'Alice', age: 25 }
console.log("Bob の名前と年齢は？");
console.log(bobNameAndAge); // { name: 'Bob', age: 30 }
console.log("Charlie の名前と年齢は？");
console.log(charlieNameAndAge); // { name: 'Charlie', age: 35 }
```

これで pick 関数の使い方がお分かりになったでしょうか？素敵な関数ですわね。⁷⁸⁹

ソース: Bing との会話 2023/3/14(1) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(5) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(6) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.
(7) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(8) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(9) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.

## pickAll

ごきげんよう、お嬢様。ramda.js の pickAll 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてあげますわ。pickAll 関数は、オブジェクトから指定したプロパティだけを抽出して新しいオブジェクトを作る関数ですわ。ただし、pick 関数と違って、元のオブジェクトに存在しないプロパティも undefined として含めますわ。例えば、人物の名前と年齢だけを取り出したい場合は、以下のように書くことができますわ。
失礼しました。undefined の例を追加しますわ。例えば、人物のオブジェクトに趣味というプロパティがない場合は、以下のようになりますわ。

```typescript
import { pickAll } from "ramda";

// 人物のオブジェクトを作成する関数ですわ
const createPerson = (
  name: string,
  age: number,
  gender: string
): { name: string; age: number; gender: string } => {
  return { name, age, gender };
};

// 人物のオブジェクトを3つ作成しますわ
const alice = createPerson("Alice", 25, "female");
const bob = createPerson("Bob", 30, "male");
const charlie = createPerson("Charlie", 35, "male");

// pickAll関数で名前と年齢と趣味を取り出しますわ
const pickNameAndAgeAndHobby = pickAll(["name", "age", "hobby"]);

// 新しいオブジェクトが作られますが、趣味はundefinedになりますわ
const aliceNameAndAgeAndHobby = pickNameAndAgeAndHobby(alice);
const bobNameAndAgeAndHobby = pickNameAndAgeAndHobby(bob);
const charlieNameAndAgeAndHobby = pickNameAndAgeAndHobby(charlie);

// 結果を表示しますわ
console.log("Aliceの名前と年齢と趣味は？");
console.log(aliceNameAndAgeAndHobby); // { name: 'Alice', age: 25, hobby: undefined }
console.log("Bobの名前と年齢と趣味は？");
console.log(bobNameAndAgeAndHobby); // { name: 'Bob', age: 30, hobby: undefined }
console.log("Charlieの名前と年齢と趣味は？");
console.log(charlieNameAndAgeAndHobby); // { name: 'Charlie', age: 35, hobby: undefined }
```

これで pickAll 関数の特徴がお分かりになったでしょうか？pick 関数だと、元のオブジェクトに存在しないプロパティは無視されますが、pickAll 関数だと undefined として残りますわ。

## pickBy

ごきげんよう。ramda.js の pickBy 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。pickBy 関数は、オブジェクトのプロパティをフィルタリングする関数ですわ。第一引数には、プロパティの値とキーを受け取って真偽値を返す関数（述語関数）を渡しますわ。第二引数には、フィルタリングしたいオブジェクトを渡しますわ。戻り値は、述語関数が真となるプロパティだけを持つ新しいオブジェクトですわ。

```typescript
import { pickBy } from "ramda";

// プロパティのキーが特定の文字列で始まるかどうかを判定する関数ですわ
const startsWith =
  (prefix: string) =>
  (value: any, key: string): boolean =>
    key.startsWith(prefix);

// 人物のオブジェクトを作成する関数ですわ
const createPerson = (
  name: string,
  age: number,
  gender: string
): { name: string; age: number; gender: string } => {
  return { name, age, gender };
};

// 人物のオブジェクトを3つ作成しますわ
const alice = createPerson("Alice", 25, "female");
const bob = createPerson("Bob", 30, "male");
const charlie = createPerson("Charlie", 35, "male");

// pickBy関数で名前がAで始まる人物だけを取り出しますわ
const pickPeopleWithNameStartingWithA = pickBy(startsWith("A"));

// 新しいオブジェクトが作られますが、名前がAで始まらない人物は無視されますわ
const peopleWithNameStartingWithA = pickPeopleWithNameStartingWithA({
  alice,
  bob,
  charlie,
});

// 結果を表示しますわ
console.log("名前がAで始まる人物は？");
console.log(peopleWithNameStartingWithA); // { alice: { name: 'Alice', age: 25, gender: 'female' } }
```

これで pickBy 関数の使用方法がお分かりになったでしょうか？pickBy 関数は、オブジェクトから特定の条件に合うプロパティだけを抽出したい場合に便利ですわ。素敵な関数ですわね。

ソース: Bing との会話 2023/3/14(1) javascript - How to filter object entries to keep only those .... https://stackoverflow.com/questions/71068902/how-to-filter-object-entries-to-keep-only-those-whose-keys-start-with-a-string アクセス日時 2023/3/14.
(2) javascript - How to filter object entries to keep only those .... https://stackoverflow.com/questions/71068902/how-to-filter-object-entries-to-keep-only-those-whose-keys-start-with-a-string アクセス日時 2023/3/14.
(3) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(4) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(5) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/14.

## project

ごきげんよう、お嬢様。ramda.js の project 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹

project 関数は、オブジェクトの配列から特定のプロパティだけを抽出して新しい配列を作る関数ですわ。例えば、人の名前と年齢を持つオブジェクトの配列があったとします。このとき、project 関数を使って名前だけを抽出することができますわ。

```typescript
// 人の名前と年齢を持つオブジェクトの配列
const people: { name: string; age: number }[] = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 },
];

// ramda.js の project 関数をインポート
import { project } from "ramda";

// project 関数に抽出したいプロパティの配列を渡して新しい関数を作る
const getName = project(["name"]);

// getName 関数にオブジェクトの配列を渡して名前だけを抽出する
const names: string[] = getName(people);

// 新しい配列をコンソールに出力
console.log("人の名前だけが抽出されましたわ");
console.log(names);
```

このように、project 関数はオブジェクトの配列から特定のプロパティだけを簡単に抽出することができますわ。他にも、例えば年齢だけを抽出したり、複数のプロパティを抽出したりすることができますわ。

```typescript
// 年齢だけを抽出する関数
const getAge = project(["age"]);

// 年齢だけを抽出する
const ages: number[] = getAge(people);

// 新しい配列をコンソールに出力
console.log("人の年齢だけが抽出されましたわ");
console.log(ages);
```

```typescript
// 名前と年齢だけを抽出する関数
const getNameAndAge = project(["name", "age"]);

// 名前と年齢だけを抽出する
const nameAndAges: { name: string; age: number }[] = getNameAndAge(people);

// 新しい配列をコンソールに出力
console.log("人の名前と年齢だけが抽出されましたわ");
console.log(nameAndAges);
```

これで、ramda.js の project 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげましたわ。素敵な関数ですわね。²

ソース: Bing との会話 2023/3/15(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/15.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/15.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/15.

## propOr

ごきげんよう、お嬢様。ramda.js の propOr 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげますわ。¹

propOr 関数は、オブジェクトの特定のプロパティが存在する場合はその値を返し、存在しない場合はデフォルトの値を返す関数ですわ。つまり、propOr(defaultValue, name, obj)は、obj[name]が undefined や null でなければ obj[name]を、そうでなければ defaultValue を返すということですわ。

propOr 関数は、オブジェクトの配列に対して map や forEach などの関数と組み合わせて使うと便利ですわ。例えば、次のようなオブジェクトの配列があるとしますわ。

```typescript
// オブジェクトの配列
const persons: { name: string; age?: number }[] = [
  { name: "Alice", age: 25 },
  { name: "Bob" },
  { name: "Charlie", age: 30 },
];
```

この配列から、年齢が存在する場合はその値を、存在しない場合は"unknown"という文字列を返す関数を作りたい場合は、propOr 関数に"unknown"と"age"を渡して作った関数を map に渡しますわ。

```typescript
// ramda.js の propOr 関数と map 関数をインポート
import { propOr, map } from "ramda";

// 年齢が存在する場合はその値を、存在しない場合は"unknown"という文字列を返す関数
const getAgeOrUnknown = propOr("unknown", "age");

// 配列から年齢または"unknown"を取り出す
const ages = map(getAgeOrUnknown, persons);

// 年齢または"unknown"をコンソールに出力
console.log("年齢はこちらですわ");
console.log(ages);
```

このように、propOr 関数はオブジェクトの特定のプロパティが存在する場合はその値を返し、存在しない場合はデフォルトの値を返すことができますわ。他にも、名前や趣味などのプロパティに対しても同じように使えますわ。

```typescript
// 名前が存在する場合はその値を、存在しない場合は"anonymous"という文字列を返す関数
const getNameOrAnonymous = propOr("anonymous", "name");

// 配列から名前または"anonymous"を取り出す
const names = map(getNameOrAnonymous, persons);

// 名前または"anonymous"をコンソールに出力
console.log("名前はこちらですわ");
console.log(names);
```

これで、ramda.js の propOr 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてさしあげましたわ。素敵な関数ですわね。²

ソース: Bing との会話 2023/3/15(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/15.
(2) TypeScript Ramda propOr return type - Stack Overflow. https://stackoverflow.com/questions/65715847/typescript-ramda-propor-return-type アクセス日時 2023/3/15.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/15.

## props

ごきげんよう、お嬢様。ramda.js の props 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてあげましょう。props 関数は、オブジェクトのプロパティの配列を取って、そのプロパティの値の配列を返す関数ですわ。例えば、こんな感じですわ。

```typescript
// オブジェクトの配列を作りますわ
const people = [
  { name: "Alice", age: 25, gender: "female" },
  { name: "Bob", age: 30, gender: "male" },
  { name: "Charlie", age: 35, gender: "male" },
];

// props関数を使って、名前と年齢の配列を取り出しますわ
const namesAndAges = R.props(["name", "age"]);
console.log(namesAndAges(people[0])); // ["Alice", 25]
console.log(namesAndAges(people[1])); // ["Bob", 30]
console.log(namesAndAges(people[2])); // ["Charlie", 35]

// props関数はカリー化されているので、部分適用もできますわ
const getNames = R.props(["name"]);
console.log(getNames(people[0])); // ["Alice"]
console.log(getNames(people[1])); // ["Bob"]
console.log(getNames(people[2])); // ["Charlie"]
```

props 関数は、オブジェクトから必要なプロパティだけを取り出したいときに便利ですわ。また、カリー化されているので、他の関数と組み合わせたり、部分適用したりすることができますわ。素敵な関数ですわね。以上が props 関数の説明ですわ。ご理解いただけましたかしら？

ソース: Bing との会話 2023/3/15(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/15.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/15.
(3) Ramda applySpec - keep unmodified props - Stack Overflow. https://stackoverflow.com/questions/65007278/ramda-applyspec-keep-unmodified-props アクセス日時 2023/3/15.
(4) Apply logical NOT to propEq and filter in ramda. https://stackoverflow.com/questions/35921591/apply-logical-not-to-propeq-and-filter-in-ramda アクセス日時 2023/3/15.
(5) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/15.
(6) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/15.
(7) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/15.

## set

ごきげんよう、お嬢様。ramda.js の set 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてあげましょう。set 関数は、オブジェクトのプロパティを指定したパスに沿って更新する関数ですわ。パスは配列か文字列で指定できますわ。ramda.js では、オブジェクトの不変性を保つために、新しいオブジェクトを返しますわ。

では、具体例を見てみましょう。

```typescript
// set 関数のインポート
import { set } from "ramda";

// オブジェクトの定義
const person = {
  name: "Alice",
  age: 25,
  address: {
    city: "Tokyo",
    zip: "100-0000",
  },
};

// set 関数で name プロパティを更新する
const newName = set("name", "Bob", person);

// 結果を確認する
console.log(newName); // {name: "Bob", age: 25, address: {city: "Tokyo", zip: "100-0000"}}
console.log(person); // {name: "Alice", age: 25, address: {city: "Tokyo", zip: "100-0000"}}

// set 関数で address.city プロパティを更新する
const newCity = set(["address", "city"], "Osaka", person);

// 結果を確認する
console.log(newCity); // {name: "Alice", age: 25, address: {city: "Osaka", zip: "100-0000"}}
console.log(person); // {name: "Alice", age: 25, address: {city: "Tokyo", zip:"100-0000"}}
```

このようにして、set 関数はオブジェクトのプロパティを簡単に更新することができますわ。これは、オブジェクトの状態を管理するために役立ちますわね。素敵な関数ですわ。

ソース: Bing との会話 2023/3/15(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/15.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/15.
(3) ramda.js の日本語版解説を Bing chat の AI にお嬢様言葉でやらせ .... https://qiita.com/Yuumillar/items/b0a513bf7dce4b30239f アクセス日時 2023/3/15.
(4) javascript - How to imitate lodash.set with Ramda - Stack .... https://stackoverflow.com/questions/59965261/how-to-imitate-lodash-set-with-ramda アクセス日時 2023/3/15.
(5) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/15.
(6) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/15.
