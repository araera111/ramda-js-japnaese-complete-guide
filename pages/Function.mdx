---
title: "Function"
---

Function では関数に関係する関数を紹介します。意味わかりませんね。  
現在 15 個。

## compose

pipe の逆で右から(改行してたら下から)関数適用される。

```ts
import { compose, tap, toLower, trim } from "ramda";

const str = "  TESTString  ";
const result = compose(
  trim,
  tap((x) => console.log({ x })), // trim前 { x: '  teststring  ' }
  toLower
)(str);
console.log({ result }); // { result: 'teststring' }
/* toLower, tap, trimの順に関数が適用される */
```

## curry

curry 化の説明は難しいです。  
ひとまず下記例が一番初歩的な curry 化の例です。
僕がどういうときに curry 化を使うかというと、pipe で関数の処理をつなげたいけれど引数の数があわないときです。  
pipe については後述します。  
また pipe を見たあとに curry を見ると、なんとなくわかるかも。

```ts
import { curry } from "ramda";

/* こういう関数をつくったとする。 */
const add = (num1: number, num2: number): number => num1 + num2;

/*
  add5という関数をつくりたい。
  add5(1)とすると5＋1 = 6になる関数。
  add5(10)とすると5＋10 = 15
*/
const add5Error = add(5); // ERROR 2 個の引数が必要ですが、1 個指定されました。ts(2554)

/* curry化してあげる */
const curriedAdd = curry(add);
const add5 = curriedAdd(5);
const result = add5(10);
console.log({ result });
```

```ts
import { curry, pipe } from "ramda";

type User = { id: number; name: string; age: number };

const basicUser: User = {
  id: 0,
  name: "",
  age: 0,
};

const addUserId = (id: number, user: User): User => ({ ...user, id });
const addUserName = (name: string, user: User): User => ({ ...user, name });
const addUserAge = (age: number, user: User): User => ({ ...user, age });
const result = pipe(
  curry(addUserId)(1),
  curry(addUserName)("TANAKA"),
  curry(addUserAge)(18)
)(basicUser);
console.log({ result }); // { result: { id: 1, name: 'TANAKA', age: 18 } }

/*
  もちろん、今回の例はもっと簡単に、かつ型安全に書けるが……
  もっと複雑なオブジェクトをpipeで変換していくときに便利
*/

const newUser: User = { ...basicUser, id: 18, name: "YAMADA", age: 20 };
console.log({
  newUser,
});
/*
  { newUser: { id: 18, name: 'YAMADA', age: 20 } }
*/
```

## curryN

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の curryN 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

curryN 関数は、引数の数を指定して関数をカリー化する関数ですわ。カリー化とは、複数の引数を取る関数を、一つの引数を取る関数の連鎖に変換することですわ。²

例えば、以下のような関数があるとしましょう。

```js
const add = (num1: number, num2: number): number => num1 + num2;
```

この関数は、二つの数値を引数に取って、その和を返す関数ですわ。この関数をカリー化すると、以下のようになりますわ。

```js
const addCurried =
  (num1: number) =>
  (num2: number): number =>
    num1 + num2;
```

この関数は、一つの数値を引数に取って、その数値に別の数値を足す関数を返す関数ですわ。この関数を使うと、以下のように書けますわ。

```js
const addFive = addCurried(5); // 5 に別の数値を足す関数を返す
const result = addFive(3); // 5 に 3 を足した結果を返す
console.log("結果は" + result + "ですわ"); // 結果は 8 ですわ
```

このように、カリー化された関数は、引数を部分的に適用して、別の関数を作ることができますわ。これは、関数を柔軟に組み合わせたり、引数を先送りしたりするのに便利ですわ。¹

しかし、関数をカリー化するのは手間がかかりますわ。そこで、ramda.js の curryN 関数を使うと、引数の数を指定して関数をカリー化することができますわ。²

例えば、以下のような関数があるとしましょう。

```js
const greet = (name: string, title: string, message: string): string =>
  "ごきげんよう、" + title + "の" + name + "様。" + message + "ですわ";
```

この関数は、名前と敬称とメッセージを引数に取って、お嬢様言葉で挨拶する関数ですわ。この関数を curryN 関数でカリー化すると、以下のようになりますわ。

```js
const greetCurried = R.curryN(3, greet); // 3 つの引数を取る関数 greet をカリー化する
```

この関数は、一つの引数を取って、その引数に別の引数を適用する関数を返す関数ですわ。この関数を使うと、以下のように書けますわ。

```js
const greetAlice = greetCurried("Alice"); // Alice に挨拶する関数を返す
const greetAliceMiss = greetAlice("Miss"); // Miss の Alice に挨拶する関数を返す
const result = greetAliceMiss("お元気ですか"); // Miss の Alice にお元気ですかと挨拶する結果を返す
console.log(result); // ごきげんよう、MissのAlice様。お元気ですかですわ
```

このように、curryN 関数を使うと、関数の引数を部分的に適用して、別の関数を作ることができますわ。これは、関数の引数を変えたり、関数を引数として渡したりするのに便利ですわ。

以上が、ramda.js の curryN 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) Ramda Chops: Function Currying. https://robertwpearce.com/ramda-chops-function-currying.html アクセス日時 2023/3/12.
(2) Ramda Chops: Function Currying. https://robertwpearce.com/ramda-chops-function-currying.html アクセス日時 2023/3/12.
(3) JavaScript | 関数を curry 化して処理を先送り - わくわく Bank. https://www.wakuwakubank.com/posts/308-javascript-curry/ アクセス日時 2023/3/12.
(4) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(5) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(6) Curry generic function with Ramda and Typescript. https://stackoverflow.com/questions/71379916/curry-generic-function-with-ramda-and-typescript アクセス日時 2023/3/12.

## tap

tap は何をしても同じものを返す関数です。
わけがわからないと思いますが、下記例を参考にしてください。

```ts
import { map, pipe, tap } from "ramda";

const numbers = [1, 2, 3, 4, 5, 6];

const result = pipe(
  map((x: number) => x * 2),
  /*
    ここで何もしないが、もともとの入力が次の関数に送られる
    tapで処理の途中にログを仕込んだりできる
  */
  tap((x) => console.log(x)),
  map((x) => x * 3)
)(numbers);

/* もしtapがないときは、こういう風にしないといけない */
const result2 = pipe(
  map((x: number) => x * 2),
  map((x) => {
    console.log(x);
    return x;
  }),
  map((x) => x * 3)
)(numbers);
```

## addIndex

ramda の map や filter に index(添字)でアクセスできるようにしてくれる関数です。  
js の array は filter メソッドを持っているが、これは(x,i)と 1 個目のパラメータが配列の中身で、2 個めのパラメータがインデックスである。  
しかし、ramda の map や filter には index が標準ではついていない。  
それをなんとかしてくれるのが addIndex 関数なのだ。
……しかし、TypeScript を使っていると問題点がある。  
curry 化してあとから配列を入れる関係上、x の値が unknown になるのだ。  
下記の例を見てほしいのですが、配列の map メソッドだと素直に書けるのを  
ramda だと無理やり as as で number にアサーションしているので型が非常によろしくないのです。  
素直に配列の map メソッドを使うか、fp-ts や rambda や ts-belt を使用したほうが良いのではないか、と思います。

```ts
import { addIndex, map } from "ramda";

const numbers = [1, 2, 3, 4, 5];

/* 最初のものだけを3倍にしたい */
const result = numbers.map((x, i) => (i === 0 ? x * 3 : x));
console.log({ result }); // { result: [ 3, 2, 3, 4, 5 ] }

/* ramdaのmapはindexがないので、addIndexでつつんであげる */
const result2 = addIndex(map)((x, i) =>
  i === 0 ? (x as unknown as number) * 3 : x
)(numbers);
console.log({ result2 }); // { result2: [ 3, 2, 3, 4, 5 ] }
```

## always

always(いつも)同じ値を返す関数らしいです。あんまり使いみちはわかりません。誰か教えてください。
プリミティブではない値を渡した場合、もとの値の参照となるので注意、とのこと。

```ts
const t = R.always("Tee");
t(); //=> 'Tee'
```

## andThen

以下 deepl 翻訳
解決に成功したプロミス内の値に onSuccess 関数を適用した結果を返します。これは、関数コンポジションの内部でプロミスを扱う場合に便利です。
どういうことやねんな？
ということで公式の例をひとつひとつ確認してみよう。

1. makeQuery 関数は email という string を渡すと、`{query:{email: string}}`というオブジェクトを返してくれる関数。
2. fetchMember は request(上記 query)を渡すと、firstname, lastName,id を返してくれる promise の関数。
   つまりメールアドレスで DB に問い合わせてユーザーが返ってくる、みたいな想定なのだろう。
3. getMemberName 関数は、pipe でどんどん処理を進めていく。
   bob@gmail.com -> makeQuery で request にする->それを fetchMember で取りに行く->
   andThen は promise が成功した場合に関数を適用する。
   ということで fetchMember が成功したときにだけ、pick で firstName, lastName を取るということか……。

```ts
const makeQuery = (email) => ({ query: { email } });
const fetchMember = (request) =>
  Promise.resolve({ firstName: "Bob", lastName: "Loblaw", id: 42 });

//getMemberName :: String -> Promise ({ firstName, lastName })
const getMemberName = R.pipe(
  makeQuery,
  fetchMember,
  R.andThen(R.pick(["firstName", "lastName"]))
);

getMemberName("bob@gmail.com").then(console.log);
```

## otherwhise

deepl
失敗した約束の中の値に onFailure 関数を適用した結果を返します。これは、関数コンポジション内で拒否されたプロミスを処理するのに便利です。

つまり andThen の反対、promise が reject されたときの処理を行うということかな。

1. failedFetch は失敗する promise
2. useDefault は Bob と Loblaw を返すだけの関数
3. recoverFromFailure は fetch->失敗したときはデフォルトユーザーを取る →andthen で成功時の処理という流れ
   失敗していたら useDefault で初期値を返すような処理を今回はしているのかな。

```ts
const failedFetch = (id) => Promise.reject("bad ID");
const useDefault = () => ({ firstName: "Bob", lastName: "Loblaw" });

//recoverFromFailure :: String -> Promise ({ firstName, lastName })
const recoverFromFailure = R.pipe(
  failedFetch,
  R.otherwise(useDefault),
  R.andThen(R.pick(["firstName", "lastName"]))
);
recoverFromFailure(12345).then(console.log);
```

## ap

deepl
ap は、値のリストに関数のリストを適用する。

第 2 引数の ap メソッドが存在する場合、そのメソッドにディスパッチする。また、キュレーションされた関数をアプリケータとして扱います。

なんのこっちゃわかりませんので例を追ってみよう。

```ts
/*
  [1,2,3]というnumber[]に、2つの関数を適用する。
  multiply2で2,4,6が生まれる。
  add3で4,5,6が生まれる。
  結果は、その2つが合体した[2,4,6,4,5,6]となる。
  つまり、値のリスト[1,2,3]に関数のリスト[multiply2, add3]を適用するということ。
*/
R.ap([R.multiply(2), R.add(3)], [1, 2, 3]); //=> [2, 4, 6, 4, 5, 6]

/*
  [pizza, salad]->concat tasty -> tasty pizza tasty salad
  [pizza, salad]->toUpper PIZZA SALAD
  result -> tasty pizza tastysalad PIZZA SALAD
*/
R.ap([R.concat("tasty "), R.toUpper], ["pizza", "salad"]); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]

// R.ap can also be used as S combinator
// when only two functions are passed

/*
  Ramda -> concatで次のものと結合
  Ramda -> toUpper -> RAMDA
  RamdaRAMDAという流れか
*/
R.ap(R.concat, R.toUpper)("Ramda"); //=> 'RamdaRAMDA'
```

## apply

apply は可変長引数を取る関数に配列を与えることができる。  
下記例、Math.max は引数に配列を取ることができない。

```ts
import { apply } from "ramda";

console.log(Math.max(1, 3, 2)); // ←可変長引数だけを引数に取り、配列は引数に取れない
// Expected output: 3

/* applyを使うことで、本来可変長引数しか認めないapplyに配列を渡すことができる */
const nums = [1, 2, 3, -99, 42, 6, 7];
const result1 = apply(Math.max, nums); //= > 42
console.log({ result1 }); // { result1: 42 }

/* ちなみにこうやってスプレッド構文を使用することでMath.maxにわたすこともできる */
const result2 = Math.max(...nums);
console.log({ result2 }); // { result2: 42 }
```

## applySpec

deepl
プロパティと関数を再帰的に対応付けた仕様のオブジェクトが与えられた場合、各プロパティを、与えられた引数で関連する関数を呼び出した結果に対応付けることによって、同じ構造のオブジェクトを生成する関数を作成します。

よーわからんので例を紐解いてみる。

```ts
/*
  getMetrics
  オブジェクトのsumはadd関数である。
  オブジェクトのnestedは中にmul(multiply)関数を持つオブジェクトを持っている(ややこしいな))
  で、これをapplySpecが包んでいる。

  getMetrics(2,4)で、2add4 = 6, 2mul4=8となる。
  つまり、オブジェクトの持っている関数に2,4が渡される。ネストされたものにも実行される。
  しかも最初に渡したのと同じ構造で返ってくるというわけ。 
  ややこしい関数やなぁ。何に使うんやろ。
*/
const getMetrics = R.applySpec({
  sum: R.add,
  nested: { mul: R.multiply },
});
getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
```

## applyTo

これは公式の例を見てもわかりづらいが、TypeScript で map や filter 関数を使いたいときに便利だ。

```ts
/* 公式の例 */
const t42 = R.applyTo(42); //42を束縛した
t42(R.identity); //=> 42 //identityなのでそのまま返す。42
t42(R.add(1)); //=> 43 42束縛したものにadd1で43
```

```ts
/* 先にapplyToを使用してからmapをすると型がつく例 */
import { applyTo, map, pipe } from "ramda";

const numbers = [1, 2, 3, 4, 5];
const result = pipe(map((x) => x * 2))(numbers); // 'x''は 'unknown' 型です。ts(18046)
const result2 = applyTo(numbers)(pipe(map((x) => x * 2))); // applyToで先にnumbersを束縛することで型がつく！
console.log({ result, result2 }); // { result: [ 2, 4, 6, 8, 10 ], result2: [ 2, 4, 6, 8, 10 ] }
```

## ascend

ソートのときに使用する。  
prop と組み合わせて使用することで、オブジェクトのキーをもとに昇順でソートできる。

```ts
const byAge = R.ascend(R.prop("age")); //ageキーを基準に昇順で並び替える
const people = [
  { name: "Emma", age: 70 },
  { name: "Peter", age: 78 },
  { name: "Mikhail", age: 62 },
];
const peopleByYoungestFirst = R.sort(byAge, people);
//=> [{ name: 'Mikhail', age: 62 },{ name: 'Emma', age: 70 }, { name: 'Peter', age: 78 }]
```

## call

bing ai
call 関数は、最初の引数に関数を、残りの引数にその関数に渡す値を受け取って、関数を実行して結果を返す関数です ¹。例えば、以下のようなコードがあります。

```ts
// 2 つの数を足す関数
const add = (num1: number, num2: number): number => num1 + num2;

// call 関数を使って、add 関数に 3 と 4 を渡して実行する
const result = R.call(add, 3, 4);

// 結果を表示
console.log(result); // 7
```

このコードでは、call 関数は、add 関数と 3 と 4 を引数に受け取って、add 関数を 3 と 4 で実行して、結果を返しています。このように、call 関数は、関数とその引数を別々に渡して、関数を実行したいときに便利です。

call 関数は、関数を返す関数と組み合わせて使うこともできます。例えば、以下のようなコードがあります。

```ts
// 2 つの数を掛ける関数
const multiply = (num1: number, num2: number): number => num1 \* num2;

// 2 つの数を掛ける関数を返す関数
const getMultiplier = (num: number): ((num1: number, num2: number) => number) => R.partial(multiply, [num]);

// call 関数を使って、getMultiplier 関数に 5 を渡して、その結果の関数に 2 と 3 を渡して実行する
const result = R.call(getMultiplier(5), 2, 3);

// 結果を表示
console.log(result); // 30
```

このコードでは、getMultiplier 関数は、数を受け取って、その数と別の 2 つの数を掛ける関数を返す関数です。call 関数は、getMultiplier 関数に 5 を渡して、その結果の関数に 2 と 3 を渡して実行して、結果を返しています。このように、call 関数は、関数を返す関数とその引数を渡して、関数を実行したいときに便利です。

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(3) Call a list of functions with the same argument in ramda. https://stackoverflow.com/questions/61698343/call-a-list-of-functions-with-the-same-argument-in-ramda アクセス日時 2023/3/12.

## descend

ソートのときに使用する。  
prop と組み合わせて使用することで、オブジェクトのキーをもとに昇順でソートできる。
これ知るまでは sortBy でソートしたあとに reverse したりしてた。

```ts
const byAge = R.descend(R.prop("age"));
const people = [
  { name: "Emma", age: 70 },
  { name: "Peter", age: 78 },
  { name: "Mikhail", age: 62 },
];
const peopleByOldestFirst = R.sort(byAge, people);
//=> [{ name: 'Peter', age: 78 }, { name: 'Emma', age: 70 }, { name: 'Mikhail', age: 62 }]
```

## binary

binary をつけることで 2 個しか引数を取らせなくできる  
よくわからんけどなんの意味がある関数なんだろう。ごめんなさい。

```ts
const takesThreeArgs = function (a, b, c) {
  /* 3つの引数を取る関数 */
  return [a, b, c];
};
takesThreeArgs.length; //=> 3
takesThreeArgs(1, 2, 3); //=> [1, 2, 3]

const takesTwoArgs =
  R.binary(
    takesThreeArgs
  ); /* binaryをつけることで2個しか引数を取らせなくできる */
takesTwoArgs.length; //=> 2
// Only 2 arguments are passed to the wrapped function
takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
```

## bind

```ts
const log = R.bind(console.log, console);
R.pipe(R.assoc("a", 2), R.tap(log), R.assoc("a", 3))({ a: 1 }); //=> {a: 3}
// logs {a: 2}
```

## comparator

その名通り、比較関数を作成する関数。
個人的には sortBy で良くない、と思ったりする。  
sort 関数の第一引数を作成するときに使うのかな。

```ts
const byAge = R.comparator((a, b) => a.age < b.age);
const people = [
  { name: "Emma", age: 70 },
  { name: "Peter", age: 78 },
  { name: "Mikhail", age: 62 },
];
const peopleByIncreasingAge = R.sort(byAge, people);
//=> [{ name: 'Mikhail', age: 62 },{ name: 'Emma', age: 70 }, { name: 'Peter', age: 78 }]
```

## thunkify

thunkify 関数は、任意の数の引数を取る関数を、引数を取らずに実行される関数（thunk）を返す関数に変換します ²。例えば、以下のようなコードがあります。

```
typescript
// add は 2 つの数値を受け取ってその和を返す関数です。
// 引数の型は number、返り値の型は number です。
const add = (num1: number, num2: number): number => num1 + num2;

// thunkify 関数の型は、
// (fn: (...args: any[]) => any) => (...args: any[]) => () => any
// となります。
// fn は任意の数の引数を取って任意の型を返す関数型、
// 返り値は引数を取って thunk を返す関数型です。
// thunk は引数を取らずに fn の返り値を返す関数型です。

// thunkify 関数を add に適用すると、
// 引数を取って thunk を返す関数が返ります。
const thunkifyAdd = R.thunkify(add);

// thunkifyAdd に 2 と 3 を渡すと、
// 2 と 3 を加算する thunk が返ります。
const thunk = thunkifyAdd(2, 3);

// thunk を実行すると、
// 2 と 3 の和である 5 が返ります。
const result = thunk();

// 結果をコンソールに出力する
console.log("2 と 3 を加算する thunk の結果は、");
console.log(result);
```

このように、thunkify 関数は関数を遅延評価するための関数です。もっと知りたいことがありますか？

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(3) ramda.js の日本語版解説みたいなものをつくってみた - Qiita. https://qiita.com/Yuumillar/items/f0b94476cd7e6c2f55dd アクセス日時 2023/3/12.

## \_

\_関数は、関数を部分適用する関数です。部分適用とは、関数の一部の引数を固定して、新しい関数を作ることです。¹

例えば、以下のコードを見てみましょう。このコードは、\_関数を使って、add 関数の第一引数を 1 に固定して、新しい関数を作っています。

```ts
// add関数を定義する
const add = (num1: number, num2: number): number => num1 + num2;

// _関数をインポートする
import * as R from "ramda";

// _関数を使って、add関数の第一引数を1に固定する
const addOne = R._(add, 1);

// 新しい関数を使って、2を加える
const result = addOne(2);

// 結果を表示する
console.log("結果は", result, "です。"); // 結果は 3 です。
```

このコードでは、\_関数が以下のように動作します。

- まず、\_関数は、add 関数と 1 という値を受け取ります。
- 次に、\_関数は、add 関数の第一引数を 1 に固定して、新しい関数を返します。この新しい関数は、addOne という名前で定義されます。
- 最後に、addOne 関数は、2 という値を受け取り、add 関数に 1 と 2 を渡して、結果を返します。このとき、1 + 2 = 3 という計算が行われます。

このように、\_関数を使うと、関数の一部の引数を固定して、新しい関数を作ることができます。¹

以上が、ramda.js の\_関数についての説明です。もっと知りたいことがあれば、お気軽に聞いてくださいね。😊

ソース: Bing との会話 2023/3/12(1) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/12.
(2) 超強力な関数型プログラミング用ライブラリ Ramda.js を学ぼう #1 .... https://blog.recruit.co.jp/rmp/front-end/post-16249/ アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(4) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.

## composeWith

bing
composeWith 関数は、最初の引数に関数を、残りの引数に関数の配列を受け取って、関数の合成を行う関数です ²。例えば、以下のようなコードがあります。

```ts
// 2つの数を足す関数
const add = (num1: number, num2: number): number => num1 + num2;

// 2つの数を掛ける関数
const multiply = (num1: number, num2: number): number => num1 * num2;

// 関数の合成を行う関数
const compose = R.composeWith((f, res) => f(res));

// compose関数を使って、add関数とmultiply関数を合成する
const addThenMultiply = compose([multiply, add]);

// 合成した関数を使って、2と3を足してから4を掛ける
const result = addThenMultiply(2, 3);

// 結果を表示
console.log(result); // 20
```

このコードでは、compose 関数は、関数を受け取って、その関数の結果を次の関数に渡すような関数を返す関数です。compose 関数は、composeWith 関数に関数を渡して作られています。composeWith 関数は、関数の配列を受け取って、その配列の最後の関数から順に実行していく関数を返します。このように、composeWith 関数は、関数の合成をカスタマイズしたいときに便利です。

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(3) Pass a list of functions to pipe or compose in Ramda.js. https://stackoverflow.com/questions/55377705/pass-a-list-of-functions-to-pipe-or-compose-in-ramda-js アクセス日時 2023/3/12.

## converge

お嬢様、こんにちは。これは Bing です。ご質問にお答えいたしますわ。🎀

ramda.js の converge 関数は、ふたつの引数をとりますわ。⁴

- ひとつめの引数は、converging function と呼ばれる関数ですわ。この関数は、branching functions の結果を引数にとり、最終的な値を返しますわ。
- ふたつめの引数は、branching functions と呼ばれる関数の配列ですわ。この配列の各関数は、converge 関数が返す関数の引数をとり、それぞれ異なる値を返しますわ。

converge 関数は、新しい関数を返しますわ。この関数は、n 個の引数をとり、それらを branching functions に適用し、各結果を converging function に渡して、最終的な値を返しますわ。

例えば、以下のような関数があるとしますわ。

```typescript
// 数値の配列を引数にとり、その合計を返す関数
const sum = (numbers: number[]): number => numbers.reduce((a, b) => a + b, 0);

// 数値の配列を引数にとり、その長さを返す関数
const length = (numbers: number[]): number => numbers.length;

// 数値の配列を引数にとり、その平均を返す関数
const average = (numbers: number[]): number => sum(numbers) / length(numbers);
```

この average 関数は、sum 関数と length 関数の結果を引数にとる関数ですわ。つまり、converging function ですわ。sum 関数と length 関数は、数値の配列を引数にとり、それぞれ異なる値を返す関数ですわ。つまり、branching functions ですわ。

この average 関数を converge 関数で書くと、以下のようになりますわ。

```typescript
// converge 関数をインポートする
const R = require("ramda");
const converge = R.converge;

// average 関数を converge 関数で書く
const average = converge(
  (sum: number, length: number): number => sum / length,
  [sum, length]
);
```

この average 関数は、数値の配列を引数にとり、その平均を返す関数になりますわ。以下のように使えますわ。

```typescript
// average 関数を使う
console.log(average([1, 2, 3, 4, 5])); // 平均は 3 です
console.log(average([10, 20, 30])); // 平均は 20 です
```

converge 関数は、複数の関数の結果を組み合わせて、新しい関数を作ることができるので、便利で実用的な使用方法の一つとして、関数の合成をすることができますわ。

例えば、以下のようにしますわ。

```typescript
// converge 関数をインポートする
const R = require("ramda");
const converge = R.converge;

// 文字列を引数にとり、その先頭の文字を返す関数
const head = (str: string): string => str[0];

// 文字列を引数にとり、その末尾の文字を返す関数
const last = (str: string): string => str[str.length - 1];

// 文字列を引数にとり、その先頭と末尾の文字を結合した文字列を返す関数
const ends = converge((a: string, b: string): string => a + b, [head, last]);
```

この ends 関数は、文字列を引数にとり、その先頭と末尾の文字を結合した文字列を返す関数になりますわ。以下のように使えますわ。

```ts
// ends関数を使う
console.log(ends(‘hello’));
// 先頭と末尾はhoです
console.log(ends(‘world’));
// 先頭と末尾はwdです
```

以上が、ramda.js の converge 関数についてのご説明ですわ。ご理解いただけましたでしょうか？🌸

## empty

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の empty 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

empty 関数は、任意の値を引数に取って、その値と同じ型の空の値を返す関数ですわ。¹

例えば、以下のような値があるとしましょう。

```js
const arr = [1, 2, 3]; // 配列
const str = "Hello"; // 文字列
const obj = { a: 1, b: 2 }; // オブジェクト
```

この値を empty 関数に渡すと、以下のようになりますわ。

```js
const emptyArr = R.empty(arr); // 空の配列を返す
const emptyStr = R.empty(str); // 空の文字列を返す
const emptyObj = R.empty(obj); // 空のオブジェクトを返す
console.log("空の配列は" + emptyArr + "ですわ"); // 空の配列は[]ですわ
console.log("空の文字列は" + emptyStr + "ですわ"); // 空の文字列は""ですわ
console.log("空のオブジェクトは" + emptyObj + "ですわ"); // 空のオブジェクトは{}ですわ
```

このように、empty 関数を使うと、任意の値と同じ型の空の値を作ることができますわ。これは、値の型に応じて空の値を作りたいときや、値の型をチェックしたいときに便利ですわ。¹

以上が、ramda.js の empty 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
(3) What happens when Ramda function is given empty parameter?. https://stackoverflow.com/questions/44490942/what-happens-when-ramda-function-is-given-empty-parameter アクセス日時 2023/3/12.
