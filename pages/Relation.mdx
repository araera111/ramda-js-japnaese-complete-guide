---
title: "Relation"
---

現在 7 個。

## equals

これは比較をしてくれる関数。
string, number はもちろん、配列や Object も判定してくれる。  
(JS では Object や配列を比較する際,JSON.stringify を行って文字列にしないと等価判定ができない)
あと、これは Object が再帰的(お互いに参照)でも判定をしっかりしてくれる。

```ts
R.equals(1, 1); //=> true
R.equals(1, "1"); //=> false
R.equals([1, 2, 3], [1, 2, 3]); //=> true

const a = {};
a.v = a;
const b = {};
b.v = b;
R.equals(a, b); //=> true
```

## union

2 つの配列の集合ですね。重複は取り除かれます。  
ところで、なんでこれ List じゃなくて Relation なんだろう。

```ts
R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
```

## max

2 つの値のうちの大きいほうが求まる。  
string にも使えて、アスキーコードとかの大きい方が求まるのかな。  
まあ数字だけにしておいたほうが無難な気はするが……。

```ts
R.max(789, 123); //=> 789
R.max("a", "b"); //=> 'b'
```

## maxby

3 個引数を取る。  
1 個目は適用する関数。  
2 個目は数字 A  
3 個目は数字 B  
まあ例を見たほうがわかりやすいかな……。

```ts
const square = (n) => n * n;

/* 
  square関数は同じ数をかける関数。
  square関数を-3と2に実行すると9と4になる。
  どちらが大きいかというと9なので-3が返ってくる。
*/
R.maxBy(square, -3, 2); //=> -3
```

## clamp

clamp は引数 1 が min, 引数 2 が max, 引数 3 が値です。  
min-max の間に収めてくれる関数ですな。  
date 型とか string 型でも使えるらしい。

```ts
R.clamp(1, 10, -5); // => 1 min1, max10で-5のときはminの1が採用される
R.clamp(1, 10, 15); // => 10 min1, max10で入力15のときはmax10が採用される
R.clamp(1, 10, 4); // => 4 min1, max10 で入力4のときはminとmaxの間なので、そのままの値が返ってくる
```

## difference

引数 1, 引数 2 ともに配列である。  
配列 1 にあって、配列 2 と被っていないものが結果として返ってくる。  
Object の場合は参照ではなく、値が一緒であれば同じと判断してくれる。

```ts
R.difference([1, 2, 3, 4], [7, 6, 5, 4, 3]); //=> [1,2] だけが引数2に存在しない(3，4は引数2にある。あと引数2の残りの数字は無関係)
R.difference([7, 6, 5, 4, 3], [1, 2, 3, 4]); //=> [7,6,5] 4,3は引数2にあるので返ってこない
R.difference([{ a: 1 }, { b: 2 }], [{ a: 1 }, { c: 3 }]); //=> [{b: 2}] {a:1}は引数2にあるので返ってこない。
```

## differenceWith

difference と何が違うねんという感じだが、つまり pred 関数を渡せるわけなのね。  
引数 1 が何をどう判定するか、という部分。これは 2 個引数を取って、2 個を比較する。  
引数 2, 3 が判定したい配列を渡す。

```ts
const cmp = (x, y) => x.a === y.a; //引数1。aプロパティを比較する
const l1 = [{ a: 1 }, { a: 2 }, { a: 3 }]; //aプロパティ1,2,3
const l2 = [{ a: 3 }, { a: 4 }]; //aプロパティが3,4
R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}] 3が被っているので消えた
```

## eqBy

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の eqBy 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

eqBy 関数は、二つの値に対して、指定した関数を適用した結果が等しいかどうかを判定する関数ですわ。¹

例えば、以下のようなオブジェクトがあるとしましょう。

```js
const alice = { name: "Alice", age: 20 }; // Alice という名前で 20 歳のオブジェクト
const bob = { name: "Bob", age: 20 }; // Bob という名前で 20 歳のオブジェクト
const charlie = { name: "Charlie", age: 25 }; // Charlie という名前で 25 歳のオブジェクト
```

このオブジェクトを eqBy 関数に渡すと、以下のようになりますわ。

```js
const eqByAge = R.eqBy(R.prop("age")); // age プロパティの値が等しいかどうかを判定する関数を作る
const aliceAndBob = eqByAge(alice, bob); // alice と bob の age プロパティの値が等しいかどうかを判定する
const aliceAndCharlie = eqByAge(alice, charlie); // alice と charlie の age プロパティの値が等しいかどうかを判定する
console.log("Alice と Bob は同じ年齢ですか？" + aliceAndBob + "ですわ"); // Alice と Bob は同じ年齢ですか？true ですわ
console.log("Alice と Charlie は同じ年齢ですか？" + aliceAndCharlie + "ですわ"); // Alice と Charlie は同じ年齢ですか？false ですわ
```

このように、eqBy 関数を使うと、二つの値に対して、任意の関数を適用した結果が等しいかどうかを簡単に判定できますわ。これは、オブジェクトの特定のプロパティや、数値や文字列の変換結果などを比較したいときに便利ですわ。³

以上が、ramda.js の eqBy 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) javascript - Comparing partial objects in ramda.js - Stack Overflow. https://stackoverflow.com/questions/37020029/comparing-partial-objects-in-ramda-js アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.
