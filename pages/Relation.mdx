---
title: "Relation"
---

現在 7 個。

## equals

これは比較をしてくれる関数。
string, number はもちろん、配列や Object も判定してくれる。  
(JS では Object や配列を比較する際,JSON.stringify を行って文字列にしないと等価判定ができない)
あと、これは Object が再帰的(お互いに参照)でも判定をしっかりしてくれる。

```ts
R.equals(1, 1); //=> true
R.equals(1, "1"); //=> false
R.equals([1, 2, 3], [1, 2, 3]); //=> true

const a = {};
a.v = a;
const b = {};
b.v = b;
R.equals(a, b); //=> true
```

## union

2 つの配列の集合ですね。重複は取り除かれます。  
ところで、なんでこれ List じゃなくて Relation なんだろう。

```ts
R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
```

## max

2 つの値のうちの大きいほうが求まる。  
string にも使えて、アスキーコードとかの大きい方が求まるのかな。  
まあ数字だけにしておいたほうが無難な気はするが……。

```ts
R.max(789, 123); //=> 789
R.max("a", "b"); //=> 'b'
```

## maxby

3 個引数を取る。  
1 個目は適用する関数。  
2 個目は数字 A  
3 個目は数字 B  
まあ例を見たほうがわかりやすいかな……。

```ts
const square = (n) => n * n;

/* 
  square関数は同じ数をかける関数。
  square関数を-3と2に実行すると9と4になる。
  どちらが大きいかというと9なので-3が返ってくる。
*/
R.maxBy(square, -3, 2); //=> -3
```

## clamp

clamp は引数 1 が min, 引数 2 が max, 引数 3 が値です。  
min-max の間に収めてくれる関数ですな。  
date 型とか string 型でも使えるらしい。

```ts
R.clamp(1, 10, -5); // => 1 min1, max10で-5のときはminの1が採用される
R.clamp(1, 10, 15); // => 10 min1, max10で入力15のときはmax10が採用される
R.clamp(1, 10, 4); // => 4 min1, max10 で入力4のときはminとmaxの間なので、そのままの値が返ってくる
```

## difference

引数 1, 引数 2 ともに配列である。  
配列 1 にあって、配列 2 と被っていないものが結果として返ってくる。  
Object の場合は参照ではなく、値が一緒であれば同じと判断してくれる。

```ts
R.difference([1, 2, 3, 4], [7, 6, 5, 4, 3]); //=> [1,2] だけが引数2に存在しない(3，4は引数2にある。あと引数2の残りの数字は無関係)
R.difference([7, 6, 5, 4, 3], [1, 2, 3, 4]); //=> [7,6,5] 4,3は引数2にあるので返ってこない
R.difference([{ a: 1 }, { b: 2 }], [{ a: 1 }, { c: 3 }]); //=> [{b: 2}] {a:1}は引数2にあるので返ってこない。
```

## differenceWith

difference と何が違うねんという感じだが、つまり pred 関数を渡せるわけなのね。  
引数 1 が何をどう判定するか、という部分。これは 2 個引数を取って、2 個を比較する。  
引数 2, 3 が判定したい配列を渡す。

```ts
const cmp = (x, y) => x.a === y.a; //引数1。aプロパティを比較する
const l1 = [{ a: 1 }, { a: 2 }, { a: 3 }]; //aプロパティ1,2,3
const l2 = [{ a: 3 }, { a: 4 }]; //aプロパティが3,4
R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}] 3が被っているので消えた
```

## eqBy

ごきげんよう、お嬢様。私は Bing と申します。お役に立てるように頑張りますわ。😊

ramda.js の eqBy 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えて差し上げますわ。

eqBy 関数は、二つの値に対して、指定した関数を適用した結果が等しいかどうかを判定する関数ですわ。¹

例えば、以下のようなオブジェクトがあるとしましょう。

```js
const alice = { name: "Alice", age: 20 }; // Alice という名前で 20 歳のオブジェクト
const bob = { name: "Bob", age: 20 }; // Bob という名前で 20 歳のオブジェクト
const charlie = { name: "Charlie", age: 25 }; // Charlie という名前で 25 歳のオブジェクト
```

このオブジェクトを eqBy 関数に渡すと、以下のようになりますわ。

```js
const eqByAge = R.eqBy(R.prop("age")); // age プロパティの値が等しいかどうかを判定する関数を作る
const aliceAndBob = eqByAge(alice, bob); // alice と bob の age プロパティの値が等しいかどうかを判定する
const aliceAndCharlie = eqByAge(alice, charlie); // alice と charlie の age プロパティの値が等しいかどうかを判定する
console.log("Alice と Bob は同じ年齢ですか？" + aliceAndBob + "ですわ"); // Alice と Bob は同じ年齢ですか？true ですわ
console.log("Alice と Charlie は同じ年齢ですか？" + aliceAndCharlie + "ですわ"); // Alice と Charlie は同じ年齢ですか？false ですわ
```

このように、eqBy 関数を使うと、二つの値に対して、任意の関数を適用した結果が等しいかどうかを簡単に判定できますわ。これは、オブジェクトの特定のプロパティや、数値や文字列の変換結果などを比較したいときに便利ですわ。³

以上が、ramda.js の eqBy 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法の説明ですわ。お嬢様のご理解に少しでもお役に立てれば幸いですわ。😊

ソース: Bing との会話 2023/3/12(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/12.
(2) javascript - Comparing partial objects in ramda.js - Stack Overflow. https://stackoverflow.com/questions/37020029/comparing-partial-objects-in-ramda-js アクセス日時 2023/3/12.
(3) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/12.

## gt

ごきげんよう、これは Bing です。ramda.js の gt 関数についてお教えしますわ。gt 関数は、二つの数値を比較して、最初の数値が二番目の数値より大きいかどうかを真偽値で返す関数です ¹。例えば、次のように使うことができますわ。

```ts
// gt 関数を使って、5 が 3 より大きいかどうかを判定する
const result: boolean = R.gt(5, 3);

// 結果を確認する
console.log(result); // true
```

この関数は、自動的にカリー化されているので、一つの引数だけを渡すと、新しい関数を返しますわ。例えば、次のようにすることができますわ。

```ts
// gt 関数に 5 を渡して、新しい関数を作る
const greaterThanFive: (b: number) => boolean = R.gt(5);

// 新しい関数に 3 を渡して、5 が 3 より大きいかどうかを判定する
const result: boolean = greaterThanFive(3);

// 結果を確認する
console.log(result); // true
```

このように、gt 関数は、二つの数値を比較して、最初の数値が二番目の数値より大きいかどうかを真偽値で返すことができますわ。ramda.js についてもっと知りたい場合は、公式サイト ¹ やドキュメント ² をご覧になってくださいませ。³ も参考になるかもしれませんわね。以上が、gt 関数の具体例と実用的な使用方法ですわ。ご理解いただけましたか？

ソース: Bing との会話 2023/3/13(1) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(3) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.

## gte

ごきげんよう、これは Bing です。ramda.js の gte 関数についてお教えしますわ。gte 関数は、二つの数値を比較して、最初の数値が二番目の数値以上かどうかを真偽値で返す関数です ¹。例えば、次のように使うことができますわ。

```ts
// gte関数を使って、5が3以上かどうかを判定する
const result: boolean = R.gte(5, 3);

// 結果を確認する
console.log(result); // true
```

この関数は、自動的にカリー化されているので、一つの引数だけを渡すと、新しい関数を返しますわ。例えば、次のようにすることができますわ。

```ts
// gte関数に5を渡して、新しい関数を作る
const greaterThanOrEqualToFive: (b: number) => boolean = R.gte(5);

// 新しい関数に3を渡して、5が3以上かどうかを判定する
const result: boolean = greaterThanOrEqualToFive(3);

// 結果を確認する
console.log(result); // true
```

このように、gte 関数は、二つの数値を比較して、最初の数値が二番目の数値以上かどうかを真偽値で返すことができますわ。ramda.js についてもっと知りたい場合は、公式サイト ¹ やドキュメント ² をご覧になってくださいませ。³ も参考になるかもしれませんわね。以上が、gte 関数の具体例と実用的な使用方法ですわ。ご理解いただけましたか？もっと勉強してくださいませね。

ソース: Bing との会話 2023/3/13(1) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.

## identical

ごきげんよう、こちらは Bing です。ramda.js の identical 関数についてお教えいたしますわ。identical 関数とは、二つの値が同一であるかどうかを判定する関数です ²。例えば、identical(1, 1)は true を、identical(1, '1')は false を返しますわ。同一であるとは、型も値も一致することを意味しますわ。例外として、NaN は自分自身とも同一ではないと判定されますわ。identical(NaN, NaN)は false を返しますわ。identical 関数は、JavaScript の===演算子と同じように動作しますわ。

identical 関数は、オブジェクトや関数の同一性をチェックするときに便利ですわ。例えば、以下のように書けますわ。

```ts
// オブジェクトの同一性をチェックする関数
const isSameObject = (obj1: object, obj2: object): boolean => {
  // identical 関数を使ってオブジェクトが同じ参照であるかどうかを判定する
  return identical(obj1, obj2);
};

// 関数の同一性をチェックする関数
const isSameFunction = (func1: Function, func2: Function): boolean => {
  // identical 関数を使って関数が同じ参照であるかどうかを判定する
  return identical(func1, func2);
};

// テスト
const obj1 = { name: "Alice", age: 20 };
const obj2 = obj1;
const obj3 = { name: "Alice", age: 20 };

const func1 = (x: number): number => x + 1;
const func2 = func1;
const func3 = (x: number): number => x + 1;

console.log(
  "obj1 と obj2 は同じオブジェクトですか？" +
    isSameObject(obj1, obj2) +
    "ですわ"
); // true
console.log(
  "obj1 と obj3 は同じオブジェクトですか？" +
    isSameObject(obj1, obj3) +
    "ですわ"
); // false
console.log(
  "func1 と func2 は同じ関数ですか？" + isSameFunction(func1, func2) + "ですわ"
); // true
console.log(
  "func1 と func3 は同じ関数ですか？" + isSameFunction(func1, func3) + "ですわ"
); // false
```

このように、identical 関数を使うと、オブジェクトや関数の同一性を簡単に判定できますわ。ramda.js の identical 関数の使い方は以上です。ご理解いただけましたか？

ソース: Bing との会話 2023/3/13(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.

## innerJoin

ごきげんよう、お嬢様。ramda.js の innerJoin 関数についてお教えいたしますわ。innerJoin 関数は、二つの配列を比較して、共通の要素を持つものだけを残す関数ですの。比較するための条件を関数として渡す必要がありますわ。例えば、以下のようなコードを見てくださいませ。

```javascript
const R = require("ramda"); // ramda.js を読み込むのですわ
const innerJoin = (pred: Function, arr1: any[], arr2: any[]): any[] =>
  R.innerJoin(pred, arr1, arr2); // innerJoin 関数を定義するのですわ
const records = [
  // レコードの配列を作るのですわ
  { id: 1, name: "Alice", age: 20 },
  { id: 2, name: "Bob", age: 21 },
  { id: 3, name: "Charlie", age: 22 },
  { id: 4, name: "David", age: 23 },
  { id: 5, name: "Eve", age: 24 },
];
const ids = [2, 4, 6]; // ID の配列を作るのですわ
const hasId = (record: any, id: number): boolean => record.id === id; // ID が一致するかどうかを判定する関数を作るのですわ
console.log(innerJoin(hasId, records, ids)); // ID が共通のレコードだけを残すのですわ
```

実行すると、以下のように表示されますわ。
`[ { id: 2, name: 'Bob', age: 21 }, { id: 4, name: 'David', age: 23 } ]`
これで、innerJoin 関数の使用方法がお分かりになりましたでしょうか。便利で実用的な使用方法としては、二つの配列の間に関係があるときに使えますわ。例えば、データベースの結合やフィルタリングなどですわ。お嬢様言葉で書いてみましたが、いかがでしたか。もっと詳しく知りたいことがありましたら、お気軽にお尋ねくださいませ。

ソース: Bing との会話 2023/3/13(1) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.
(4) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(5) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(6) javascript - How to use Ramda pipe? - Stack Overflow. https://stackoverflow.com/questions/48165003/how-to-use-ramda-pipe アクセス日時 2023/3/13.
(7) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.
(8) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(9) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.

## intersection

ごきげんよう、お嬢様。ramda.js の intersection 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法をお教えいたしますわ。intersection 関数は、二つの配列の共通の要素を含む新しい配列を返す関数ですわ。例えば、次のように使えますわ。

```typescript
// 二つの配列の共通の要素を返す関数を作る
const intersection = (arr1: any[], arr2: any[]): any[] =>
  R.intersection(arr1, arr2);

// 二つの配列を用意する
const arr1 = [1, 2, 3, 4];
const arr2 = [3, 4, 5, 6];

// 関数に適用する
const newArr = intersection(arr1, arr2); // [3, 4]

// 配列の内容を確認する
console.log("一つ目の配列はこうですわ: " + arr1); // 一つ目の配列はこうですわ: 1,2,3,4
console.log("二つ目の配列はこうですわ: " + arr2); // 二つ目の配列はこうですわ: 3,4,5,6
console.log("共通の要素を含む配列はこうですわ: " + newArr); // 共通の要素を含む配列はこうですわ: 3,4
```

このように、intersection 関数は二つの配列の共通の要素を見つけるのに便利な関数ですわ。また、intersection 関数はカリー化されているので、部分適用ができますわ。例えば、次のように使えますわ。

```typescript
// 一つの配列の要素と共通する要素を返す関数を作る
const intersectionWithArr1 = R.intersection(arr1);

// 別の配列を用意する
const arr3 = [4, 5, 6, 7];

// 関数に適用する
const newArr2 = intersectionWithArr1(arr3); // [4]

// 配列の内容を確認する
console.log("一つ目の配列はこうですわ: " + arr1); // 一つ目の配列はこうですわ: 1,2,3,4
console.log("三つ目の配列はこうですわ: " + arr3); // 三つ目の配列はこうですわ: 4,5,6,7
console.log("共通の要素を含む配列はこうですわ: " + newArr2); // 共通の要素を含む配列はこうですわ: 4
```

このように、intersection 関数は二つの配列の共通の要素を見つけるのに便利な関数ですわ。ramda.js には他にもたくさんの関数がありますので、ぜひドキュメント ¹² や GitHub³ をご覧になってくださいませ。お役に立てれば幸いですわ。では、ごきげんよう。🎀

ソース: Bing との会話 2023/3/13(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(3) Ramda Documentation. https://ramdajs.com/0.9/docs/ アクセス日時 2023/3/13.
(4) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/13.
(5) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/13.
(6) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/13.

## lt

ごきげんよう、お嬢様。ramda.js の lt 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてあげますわ。²

lt 関数は、less than の略ですわ。lt 関数は、2 つの値を引数にとって、最初の値が 2 番目の値より小さいかどうかを真偽値で返す関数ですわ。例えば、以下のように使えますわ。

```typescript
const lt = (a: number | string, b: number | string): boolean => a < b;
console.log(lt(3, 5)); //=> true
console.log(lt(5, 3)); //=> false
console.log(lt("a", "b")); //=> true
console.log(lt("b", "a")); //=> false
```

lt 関数は、数値や文字列に対して使えますわ。数値は数値の大小で比較しますわ。文字列は辞書順で比較しますわ。lt 関数は、ramda.js の特徴であるカリー化されていますわ。カリー化とは、引数を 1 つずつ渡して、部分適用された関数を返すことですわ。例えば、以下のように使えますわ。

```typescript
const lt3 = lt(3); //=> 3 より小さいかどうかを判定する関数
console.log(lt3(5)); //=> false
console.log(lt3(2)); //=> true
```

lt 関数に最初の引数を渡すと、2 番目の引数を待つ関数が返りますわ。この関数に 2 番目の引数を渡すと、真偽値が返りますわ。カリー化された関数は、他の関数と組み合わせて使うと便利ですわ。例えば、以下のように使えますわ。

```typescript
const nums = [1, 2, 3, 4, 5]; //=> 数値の配列
const filter = (pred: (a: any) => boolean, list: any[]): any[] =>
  list.filter(pred); //=> 配列から条件に合う要素だけを取り出す関数
const filterLt3 = filter(lt3); //=> 配列から 3 より小さい要素だけを取り出す関数
console.log(filterLt3(nums)); //=> [1, 2]
```

filter 関数は、条件を表す関数と配列を引数にとって、配列から条件に合う要素だけを取り出す関数ですわ。filter 関数に lt3 関数を渡すと、配列から 3 より小さい要素だけを取り出す関数が返りますわ。この関数に nums 配列を渡すと、[1, 2]という配列が返りますわ。lt 関数は、filter 関数や sort 関数などの高階関数と一緒に使うと、配列の要素を比較したり並べ替えたりするのに便利ですわ。

lt 関数の使い方は、これでお分かりになりましたか？

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.

## lte

ごきげんよう、お嬢様。ramda.js の lte 関数について、わかりやすい具体例とともにできるだけ便利で実用的な使用方法を教えてあげますわ。¹

lte 関数は、less than or equal の略ですわ。lte 関数は、2 つの値を引数にとって、最初の値が 2 番目の値以下かどうかを真偽値で返す関数ですわ。例えば、以下のように使えますわ。

```typescript
const lte = (a: number | string, b: number | string): boolean => a <= b;
console.log(lte(3, 5)); //=> true
console.log(lte(5, 3)); //=> false
console.log(lte(3, 3)); //=> true
console.log(lte("a", "b")); //=> true
console.log(lte("b", "a")); //=> false
console.log(lte("a", "a")); //=> true
```

lte 関数は、数値や文字列に対して使えますわ。数値は数値の大小で比較しますわ。文字列は辞書順で比較しますわ。lte 関数は、ramda.js の特徴であるカリー化されていますわ。カリー化とは、引数を 1 つずつ渡して、部分適用された関数を返すことですわ。例えば、以下のように使えますわ。

```typescript
const lte3 = lte(3); //=> 3以下かどうかを判定する関数
console.log(lte3(5)); //=> false
console.log(lte3(2)); //=> true
console.log(lte3(3)); //=> true
```

lte 関数に最初の引数を渡すと、2 番目の引数を待つ関数が返りますわ。この関数に 2 番目の引数を渡すと、真偽値が返りますわ。カリー化された関数は、他の関数と組み合わせて使うと便利ですわ。例えば、以下のように使えますわ。

```typescript
const nums = [1, 2, 3, 4, 5]; //=> 数値の配列
const filter = (pred: (a: any) => boolean, list: any[]): any[] =>
  list.filter(pred); //=> 配列から条件に合う要素だけを取り出す関数
const filterLte3 = filter(lte3); //=> 配列から3以下の要素だけを取り出す関数
console.log(filterLte3(nums)); //=> [1, 2, 3]
```

filter 関数は、条件を表す関数と配列を引数にとって、配列から条件に合う要素だけを取り出す関数ですわ。filter 関数に lte3 関数を渡すと、配列から 3 以下の要素だけを取り出す関数が返りますわ。この関数に nums 配列を渡すと、[1, 2, 3]という配列が返りますわ。lte 関数は、filter 関数や sort 関数などの高階関数と一緒に使うと、配列の要素を比較したり並べ替えたりするのに便利ですわ。

lte 関数の使い方は、これでお分かりになりましたか？

ソース: Bing との会話 2023/3/14(1) Ramda Documentation. https://ramdajs.com/docs/ アクセス日時 2023/3/14.
(2) Ramda Documentation. https://ramdajs.com/ アクセス日時 2023/3/14.
(3) GitHub - ramda/ramda: Practical functional Javascript. https://github.com/ramda/ramda アクセス日時 2023/3/14.
